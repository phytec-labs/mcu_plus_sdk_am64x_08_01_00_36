<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Understanding the bootflow and bootloaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('BOOTFLOW_GUIDE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Understanding the bootflow and bootloaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md164">Introduction</a></li>
<li class="level1"><a href="#autotoc_md165">Additional References</a></li>
<li class="level1"><a href="#autotoc_md166">Preparing the application for boot</a></li>
<li class="level1"><a href="#autotoc_md167">Flashing the application for boot</a></li>
<li class="level1"><a href="#autotoc_md168">Booting the application</a><ul><li class="level2"><a href="#autotoc_md169">ROM Boot</a></li>
<li class="level2"><a href="#autotoc_md170">SBL Boot</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md171">Secondary Bootloaders</a><ul><li class="level2"><a href="#autotoc_md172">SBL NULL</a></li>
<li class="level2"><a href="#autotoc_md173">SBL SD</a></li>
<li class="level2"><a href="#autotoc_md174">SBL OSPI</a></li>
<li class="level2"><a href="#autotoc_md175">SBL UART</a></li>
<li class="level2"><a href="#autotoc_md176">SBL OSPI LINUX</a></li>
<li class="level2"><a href="#autotoc_md177">SBL EMMC LINUX</a></li>
<li class="level2"><a href="#autotoc_md178">Preparing the SBL for boot</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_developer_guides_bootflow"></a></p>
<h1><a class="anchor" id="autotoc_md164"></a>
Introduction</h1>
<p>Booting user defined applications on a SOC involves multiples steps as listed below,</p><ul>
<li>Firstly, there are multiple steps involved to convert a user application, created using a compiler+linker toolchain, into a binary format that is suitable to be booted by the SOC</li>
<li>Next, we need to flash this binary to the EVM flash</li>
<li>Finally, when the SOC is powered on, the previously flashed binary is executed.</li>
<li>After powering on the EVM, the bootflow takes place mainly in two steps<ul>
<li><b>ROM boot</b>, in which the ROM bootloader boots a secondary bootloader or an SBL</li>
<li><b>SBL boot</b> in which the secondary bootloader boots the application</li>
</ul>
</li>
<li>Note, that a system application itself can consist of multiple CPU specific application binaries that all collaborate together to realize the overall system goal.</li>
</ul>
<p>This section details these steps and gives an overview of the bootloaders to understand the process better. This section also describes the steps to enable XIP (eXecute In Place) for your applications.</p>
<h1><a class="anchor" id="autotoc_md165"></a>
Additional References</h1>
<p>See also these additional pages for more details and examples about the boot flow,</p>
<ul>
<li>To understand different secondary bootloader (SBL) examples see,<ul>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_NULL.html">SBL NULL</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART_UNIFLASH.html">SBL UART Uniflash</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_SD.html">SBL SD</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI.html">SBL OSPI</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART.html">SBL UART</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI_MULTI_PARTITION.html">SBL OSPI Multi-Partition</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI_LINUX.html">SBL OSPI Linux</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_EMMC_LINUX.html">SBL EMMC Linux</a></li>
</ul>
</li>
<li>To understand the flashing steps, see <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a></li>
<li>To understand the boot image creation tools, see <a class="el" href="TOOLS_BOOT.html">Booting Tools</a></li>
<li>To understand the steps to use XIP, see <a class="el" href="BOOTFLOW_XIP.html">Enabling XIP or eXecute In Place</a></li>
<li>To understand the details on SBL Booting linux from OSPI, see <a class="el" href="SBL_BOOTING_LINUX_OSPI.html">SBL Booting Linux From OSPI</a></li>
<li>To understand the details on SBL Booting linux from eMMC, see <a class="el" href="SBL_BOOTING_LINUX_EMMC.html">SBL Booting Linux From eMMC</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md166"></a>
Preparing the application for boot</h1>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<p>Shown below are the different steps that are done to convert the compiler+linker generated application <code>.out</code> into a format suitable for flashing and booting</p>
<ul>
<li>For each CPU, the compiler+linker toolchain is used to create the application .out "ELF" file which can be loaded and run via CCS</li>
<li>The below "post build" steps are then used to convert the application .out into a "flash" friendly format<ul>
<li>For each CPU, <code>out2rpc</code> is used to convert the ELF .out to a binary file containing only the loadable sections. This is called a RPRC file.</li>
<li>For each CPU, <code>xipGen</code> is used to split this RPRC file into two RPRC files.<ul>
<li>One RPRC, containing the section that during boot need to be loaded to RAM</li>
<li>Second RPRC, containing the section that during boot are not loaded to RAM but are instead "eXecuted In Place", i.e XIP</li>
</ul>
</li>
<li><code>multiCoreGen</code> is then used to combine all the non-XIP RPRC files per CPU into a single <code>.appimage</code> file which is a concatenation of the individual CPU specific RPRC files.</li>
<li><code>multiCoreGen</code> is used again to combine all the XIP RPRC files per CPU into a single <code>.appimage_xip</code> file which is a concatenation of the individual CPU specific RPRC XIP files.</li>
</ul>
</li>
<li>This <code>.appimage</code> and <code>.appimage_xip</code> is then flash to the EVM</li>
</ul>
<p> <style>div.image img[src="bootflow_post_build_steps.png"]{width:50%}</style> </p><div class="image">
<img src="bootflow_post_build_steps.png" alt=""/>
<div class="caption">
Post build steps</div></div>
<h1><a class="anchor" id="autotoc_md167"></a>
Flashing the application for boot</h1>
<ul>
<li>Once the application images (<code>.appimage</code> and <code>.appimage_xip</code>) are created one needs to copy or flash these to a supported boot media so that the application can start executing once the SOC is powered ON</li>
<li>When flashing the application we also need to flash a bootloader or SBL image.</li>
<li>See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for detailed steps that are done to flash a user application </li>
</ul>
<h1><a class="anchor" id="autotoc_md168"></a>
Booting the application</h1>
<p>After a SBL and application image is flashed, shown below is the high level boot flow, after the SOC is powered on.</p>
<p> <style>div.image img[src="bootflow_main.png"]{width:40%}</style> </p><div class="image">
<img src="bootflow_main.png" alt=""/>
<div class="caption">
HIGH LEVEL BOOTFLOW</div></div>
<h2><a class="anchor" id="autotoc_md169"></a>
ROM Boot</h2>
<ul>
<li>As soon as the EVM is powered ON, the ROM bootloader or RBL starts running. The RBL is the primary bootloader.</li>
<li>Depending on which boot mode is selected on the EVM, the RBL will load the <b>secondary bootloader</b> or SBL from a boot media (OSPI flash, SD card or via UART).</li>
<li>Rest of the booting is done by the SBL.</li>
<li>The RBL expects the image it boots (SBL in our case) to always be signed. Refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more information on signing scripts.</li>
</ul>
<h2><a class="anchor" id="autotoc_md170"></a>
SBL Boot</h2>
<ul>
<li>The SBL is essentially an example application of the bootloader library.</li>
<li>We call it a secondary bootloader because it is booted by the RBL, which is the primary bootloader.</li>
<li>An SBL typically does a bunch of SOC specific initializations and proceeds to the application loading.</li>
<li>In case of AM64X EVM, the SBL loads the SYSFW to the Cortex M3 and sends the board cfg to the SYSFW once M3 is booted.</li>
<li>Depending on the type of SBL loaded, SBL looks for the <b>multicore appimage</b> (refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more on multicore appimage) of the application binary at a specified location in a boot media.</li>
<li>If the appimage is found, the multicore appimage is parsed into multiple <b>RPRCs</b>. These are optimized binaries which are then loaded into individual CPUs.</li>
<li>Each RPRC image will have information regarding the core on which it is to be loaded, entry points and multiple sections of that application binary</li>
<li>The SBL uses this information to initialize each core which has a valid RPRC. It then loads the RPRC according to the sections specified, sets the entry points and releases the core from reset. Now the core will start running</li>
</ul>
<p> <video autoplay playinline muted controls width=50% style="display:block; margin: 0 auto;"> <source src="sbl_boot.mp4" type="video/mp4"> </video> <p style="text-align: center;"><strong>SBL BOOT</strong></p> </p>
<h1><a class="anchor" id="autotoc_md171"></a>
Secondary Bootloaders</h1>
<p>Depending on the boot media from which we load the application binary, we have multiple SBLs like <code>sbl_ospi</code>, <code>sbl_uart</code> etc. A bare minimum SBL called the <code>sbl_null</code> is also included which aids the users to load their applications via CCS.</p>
<h2><a class="anchor" id="autotoc_md172"></a>
SBL NULL</h2>
<ul>
<li>The <code>sbl_null</code> is a secondary bootloader which doesn't load any application binary, but just does the SOC initialization and puts all the cores in WFI (Wait For Interrupt) mode.</li>
<li>This is referred to as the SOC initialization binary, refer <a class="el" href="EVM_SETUP_PAGE.html#EVM_FLASH_SOC_INIT">Flash SOC Initialization Binary</a> for more on this.</li>
</ul>
<h2><a class="anchor" id="autotoc_md173"></a>
SBL SD</h2>
<ul>
<li>The <code>sbl_sd</code> is a secondary bootloader which reads the application image file from the SD card and then moves on to core initialization and other steps</li>
<li>To boot an application using the <code>sbl_sd</code>, the application image needs to be copied to the SD card as a file named "app". Make sure that the SD card is formatted to have a FAT partition. To know more about the SD card partitioning please refer <a class="el" href="EVM_SETUP_PAGE.html#EVM_SOC_INIT_SD_BOOT_MODE">SOC Initialization Using SD BOOT</a></li>
<li>Follow the steps in the above referred page to partition the SD card. For a complete boot from SD card, both the <code>sbl_sd</code> binary and the application image binary has to be present as files in the SD card. You have to rename the <code>sbl_sd</code> appimage as 'tiboot3.bin'. <pre class="fragment">  copy file to SD card =&gt; ${SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/am64x-evm/sbl_sd.release.tiimage
  rename in SD card as =&gt; tiboot3.bin
</pre></li>
<li>Similarly you can copy any appimage file to the SD card and rename in the SD card as "app" so that the SBL can pick it up.</li>
<li>Currently the <code>sbl_sd</code> reads the full appimage file into an MSRAM buffer and then parses the multicore appimage. Because of this reason <b>appimages higher than ~380 KB in size can't be booted by <code>sbl_sd</code> as of now</b>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md174"></a>
SBL OSPI</h2>
<ul>
<li>The <code>sbl_ospi</code> is a secondary bootloader which reads and parses the application image from a location in the OSPI flash and then moves on to core initialization and other steps</li>
<li>To boot an application using the <code>sbl_ospi</code>, the application image needs to be flashed at a particular location in the OSPI flash memory.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_ospi</code> application. Currently this is 0x80000. In most cases you wouldn't need to change this.</li>
<li>To flash an application (or any file in fact) to a location in the OSPI flash memory, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md175"></a>
SBL UART</h2>
<ul>
<li>The <code>sbl_uart</code> is a secondary bootloader which receives the multicore appimage via UART, stores it in memory and then does the parsing, core initialization etc.</li>
<li>To boot an application using the <code>sbl_uart</code>, you can refer to <a class="el" href="TOOLS_BOOT.html#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a> subsection. Detailed steps on the usage is mentioned in the same subsection.</li>
</ul>
<h2><a class="anchor" id="autotoc_md176"></a>
SBL OSPI LINUX</h2>
<ul>
<li>The <code>sbl_ospi_linux</code> is a secondary bootloader which boots Linux on A53 core and RTOS/NORTOS application on R5, M4 cores.</li>
<li>To boot Linux and RTOS/NORTOS applications using <code>sbl_ospi_linux</code>, the Linux appimage (see <a class="el" href="TOOLS_BOOT.html#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a>) and the RTOS/NORTOS application images needs to be flashed at a particular location in the OSPI flash memory.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_ospi_linux</code> application. Currently this is 0x80000 for RTOS/NORTOS images and 0x300000 for Linux application image. In most cases you wouldn't need to change this.</li>
<li>To flash an application (or any file in fact) to a location in the OSPI flash memory, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md177"></a>
SBL EMMC LINUX</h2>
<ul>
<li>The <code>sbl_emmc_linux</code> is a secondary bootloader which boots Linux on A53 core and RTOS/NORTOS application on R5, M4 cores from eMMC.</li>
<li>To boot Linux and RTOS/NORTOS applications using <code>sbl_emmc_linux</code>, the Linux appimage (see <a class="el" href="TOOLS_BOOT.html#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a>) and the RTOS/NORTOS application images needs to be flashed at a particular location in the eMMC.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_emmc_linux</code> application. Currently this is 0x800000 for RTOS/NORTOS images and 0xA00000 for Linux application image. In most cases you wouldn't need to change this.</li>
<li>To flash an application (or any file in fact) to a location in the eMMC, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md178"></a>
Preparing the SBL for boot</h2>
<p>The SBL is like any other application, created using the same compiler and linker toolchain. However the steps to convert the application <code>.out</code> into a bootable image are different for SBL as listed below</p>
<ul>
<li>The SBL entry point needs to be different vs other applications. On AM64X after power-ON ROM boots the SBL and sets the entry point of SBL to both R5FSS0-0 as well as R5FSS0-1. However for SBL we need to detect the core and run SBL only on Core0 and keep Core1 in <code>wfi</code> loop. This is done by specifying a different entry point <code>-e_vectors_sbl</code> in the linker command file for the SBL application. In <code>_vectors_sbl</code> the very first thing it does is detect the core and continue execution for Core0, while if the core is Core1 then it enters <code>wfi</code> loop.</li>
<li>Other special factors for SBL application are listed below<ul>
<li>After entering <code>main()</code>, make sure to call <code>Bootloader_socLoadSysFw</code> to load the SYSFW to DMSC M3 and setup a "board config"</li>
<li>The linker command file for SBL has to place vectors at address <code>0x70000000</code> and this is the entry point for the SBL.</li>
<li>Nothing should be placed in ATCM or BTCM</li>
<li>Only the region <code>0x70000000</code> to <code>0x70080000</code> should be used by SBL code, data, stack etc</li>
</ul>
</li>
<li>After building, the SBL application <code>.out</code> file is first converted to a binary format <code>.bin</code> using the GCC <code>objcopy</code> tool.<ul>
<li>This copies the loadable sections from the .out into a binary image stripping all symbol and section information.</li>
<li>If there are two loadable sections in the image which are not contiguous then <code>objcopy</code> fills the gaps with <code>0xFF</code>.</li>
<li>It is highly recommended to keep all loadable sections together within a SBL application.</li>
</ul>
</li>
<li>This <code>.bin</code> file is then signed using the <a class="el" href="TOOLS_BOOT.html#TOOLS_BOOT_SIGNING">Signing Scripts</a> to create the final <code>.tiimage</code> bootable image.<ul>
<li>A default key is used for this.</li>
<li>This is a ROM bootloader requirement and is needed even on a non-secure device.</li>
</ul>
</li>
<li>This <code>.tiimage</code> file can then be flashed or copied to a boot image using the <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
