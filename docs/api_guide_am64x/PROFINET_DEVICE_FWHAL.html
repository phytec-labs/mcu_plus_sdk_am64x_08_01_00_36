<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Profinet Device FWHAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('PROFINET_DEVICE_FWHAL.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Profinet Device FWHAL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md676">Introduction</a></li>
<li class="level1"><a href="#autotoc_md677">PRU-ICSS Profinet Device Firmware</a><ul><li class="level2"><a href="#autotoc_md678">Features Supported</a></li>
<li class="level2"><a href="#autotoc_md679">Features Not Supported</a></li>
<li class="level2"><a href="#autotoc_md680">Known Issues</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md681">Important Files and Directory Structure</a></li>
<li class="level1"><a href="#autotoc_md682">Terms and Abbreviations</a></li>
<li class="level1"><a href="#autotoc_md683">API Documentation</a></li>
<li class="level1"><a href="#autotoc_md684">Procedure to kick-off the Profinet Device</a></li>
<li class="level1"><a href="#autotoc_md685">Integration with ICSS-EMAC</a><ul><li class="level2"><a href="#autotoc_md686">Interface with ICSS-EMAC</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md687">OS Components</a><ul><li class="level2"><a href="#autotoc_md688">Interrupts</a></li>
<li class="level2"><a href="#autotoc_md689">Tasks</a></li>
<li class="level2"><a href="#autotoc_md690">Semaphores</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md691">CPM/PPM Management</a><ul><li class="level2"><a href="#autotoc_md692">Initialization</a></li>
<li class="level2"><a href="#autotoc_md693">Establishing a connection</a><ul><li class="level3"><a href="#autotoc_md694">Establishing a PPM connection</a></li>
<li class="level3"><a href="#autotoc_md695">Establishing a CPM connection</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md696">Updating CPM/PPM data</a></li>
</ul>
</li>
<li class="level1"><a href="#PROFINET_DEVICE_TRIPLE_BUFFER_MANAGEMENT">Triple Buffer Management</a><ul><li class="level2"><a href="#autotoc_md697">PPM Triple buffer management</a></li>
<li class="level2"><a href="#autotoc_md698">CPM Triple buffer management</a></li>
</ul>
</li>
<li class="level1"><a href="#PROFINET_DEVICE_MRP">Media Redundancy Protocol (MRP)</a><ul><li class="level2"><a href="#autotoc_md699">MRP State Machine</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md700">Profinet IRT Legacy Startup Support</a><ul><li class="level2"><a href="#autotoc_md701">Profinet IRT Legacy Startup State Machine</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md702">Phase Management</a><ul><li class="level2"><a href="#autotoc_md703">Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md704">PTCP</a><ul><li class="level2"><a href="#autotoc_md705">Implementation</a><ul><li class="level3"><a href="#autotoc_md706">SYNC handling</a></li>
<li class="level3"><a href="#autotoc_md707">Delay Handling</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md708">Integrating with the stack</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md709">Isochronous Mode</a><ul><li class="level2"><a href="#autotoc_md710">Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md711">DCP Filter</a></li>
<li class="level1"><a href="#autotoc_md712">Multicast Filter Tables</a></li>
<li class="level1"><a href="#autotoc_md713">Watchdog Timer</a></li>
<li class="level1"><a href="#PROFINET_DEVICE_ADDITIONAL_REFERENCES">Additional References</a></li>
<li class="level1"><a href="#autotoc_md714">See also</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_industrial_comms_profinet_device"></a></p>
<h1><a class="anchor" id="autotoc_md676"></a>
Introduction</h1>
<p>This software is designed for the TI SoCs with PRU-ICSS IP to enable customers add Profinet Device protocol support to their system. It provides Profinet ASIC like functionality integrated into TI SoCs.</p>
<div class="image">
<img src="Profinet_Device_Software_Architecture.PNG" alt=""/>
<div class="caption">
Software Architecture</div></div>
<p>Profinet firmware for PRU-ICSS is a black box product maintained by TI. Profinet Device FWHAL (Firmware and Hardware Abstraction Layer) allows loading and run Profinet firmware and acts as an interface with the firmware. FWHAL implements the key interface between Profinet Device firmware and Profinet Device firm stack. It provides stack interface for CPM/PPM management, Triple Buffer Management, MRP, DCP Filter, Multicast Filter, Phase management and PTCP modules.</p>
<h1><a class="anchor" id="autotoc_md677"></a>
PRU-ICSS Profinet Device Firmware</h1>
<h2><a class="anchor" id="autotoc_md678"></a>
Features Supported</h2>
<ul>
<li>Supports minimum cycle time of 250 us</li>
<li>Integrated two-port cut-through switch, 100 Mb/s Full Duplex<ul>
<li>Relative forwarder, computes the Forward FSO for RTC3 frames which have to be forwarded</li>
</ul>
</li>
<li>PROFINET Quality of Service (QoS)<ul>
<li>Four priority receive queues on host port, each queue 6 KB in size</li>
<li>Four priority transmit queues on each physical port, each queue 3 KB in size</li>
</ul>
</li>
<li>Up to 8 Application Relations (ARs)</li>
<li>8 IOCRs<ul>
<li>8 Consumer Protocol Machines (CPM)</li>
<li>8 Provider Protocol Machines (PPM)</li>
<li>Supports PROFINET IO data size from 40 to 1440 Bytes</li>
</ul>
</li>
<li>Data Hold Timer</li>
<li>DCP Identify Filter<ul>
<li>DCP Identify frame is given to host only if it is meant for it otherwise it is just forwarded.</li>
<li>Reduces the DCP Identify frames reaching host at a particular node at network startup</li>
</ul>
</li>
<li>One Step Time Synchronization (PTCP)</li>
<li>1 millisecond buffering per port</li>
<li>802.1d learning bridge for received source MAC addresses</li>
<li>PNIO static routing and custom FDB for multicast addresses</li>
<li>Interrupt Pacing</li>
<li>Isochronous Mode</li>
</ul>
<h2><a class="anchor" id="autotoc_md679"></a>
Features Not Supported</h2>
<ul>
<li>Media Redundancy Protocol (MRP)<ul>
<li>Bump less transition of PROFINET connection to redundant path on ring break</li>
<li>Switch address learned table (FDB) is flushed in 2.4 micro second</li>
</ul>
</li>
<li>Profinet IRT MRPD support</li>
<li>Profinet IRT High Performance Profile</li>
</ul>
<h2><a class="anchor" id="autotoc_md680"></a>
Known Issues</h2>
<table class="doxtable">
<tr>
<th>Record ID </th><th>Details </th><th>Workaround  </th></tr>
<tr>
<td>PINDSW-4725 </td><td>PLC communication unstable with Profinet IRT Device in RGMII mode </td><td>-  </td></tr>
<tr>
<td>PINDSW-4727 </td><td>Different Access Ways Test failing with Profinet IRT application </td><td>-  </td></tr>
<tr>
<td>PINDSW-4922 </td><td>SPIRTA Test failures with Profinet IRT application on AM64x </td><td>-  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md681"></a>
Important Files and Directory Structure</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/industrial_comms </td></tr>
<tr>
<td>profinet_device_demo </td><td>Profinet Device Examples (based on pre-integrated stack)  </td></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/source/industrial_comms/profinet_device </td></tr>
<tr>
<td>icss_fwhal/firmware </td><td>Firmware for the PRU cores in PRU-ICSS. <b>Firmware Version : 0.14.5</b>   </td></tr>
<tr>
<td>icss_fwhal/lib/ </td><td>FWHAL library for Profinet Device  </td></tr>
<tr>
<td>icss_fwhal/*.c </td><td>FWHAL source files  </td></tr>
<tr>
<td>icss_fwhal/*.h </td><td>FWHAL interface files  </td></tr>
<tr>
<td>stack </td><td>Stack header files and stack library  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md682"></a>
Terms and Abbreviations</h1>
<table class="doxtable">
<tr>
<th>Abbreviation </th><th>Expansion  </th></tr>
<tr>
<td>PRU-ICSS </td><td>Programmable Real-Time Unit Industrial Communication Subsystem  </td></tr>
<tr>
<td>CPM </td><td>Consumer Protocol Machine  </td></tr>
<tr>
<td>PPM </td><td>Producer Protocol Machine </td></tr>
<tr>
<td>DHT </td><td>Data Hold Timer </td></tr>
<tr>
<td>AR </td><td>Application Relation </td></tr>
<tr>
<td>NRT </td><td>Non Real Time </td></tr>
<tr>
<td>LLDP </td><td>Link Layer Discovery Protocol </td></tr>
<tr>
<td>MRP </td><td>Media Redundancy Protocol </td></tr>
<tr>
<td>DCP </td><td>Discovery and Basic Configuration Protocol  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md683"></a>
API Documentation</h1>
<p>Please see <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html">APIs for Profinet Device FWHAL</a> for API documentation. It is recommended to use these FWHAL APIs in the stack adaptation files.</p>
<h1><a class="anchor" id="autotoc_md684"></a>
Procedure to kick-off the Profinet Device</h1>
<ul>
<li>Initialize ICSS-EMAC to work as a switch</li>
<li>Initialize the required tasks and interrupts</li>
<li>Initialize the Profinet Driver, PTCP and Memory (CPM/PPM Buffers and lists) and PRU-ICSS INTC</li>
<li>Load Profinet firmware into PRUs of PRU-ICSS</li>
<li>Initialize the Profinet slave stack</li>
<li>Start firmware</li>
<li>Handle the events as needed. The event/ISR definitions are availale in iRtcDrv.c, these have respective callbacks that can be registered to custom stack APIs.</li>
</ul>
<h1><a class="anchor" id="autotoc_md685"></a>
Integration with ICSS-EMAC</h1>
<p>Profinet examples use the ICSS-EMAC as its base switch layer. The PRU Firmware is customized for Profinet functionalities. The NRT (non-real time) traffic is handled by ICSS-EMAC, wherein the packets are forwarded either to the TCP stack or a custom custom callback (configurable in ICSS-EMAC).</p>
<h2><a class="anchor" id="autotoc_md686"></a>
Interface with ICSS-EMAC</h2>
<p>In case of Profinet firmware, the queues are designed as shown in the diagram below. The highest priority queues are used for LLDP, MRP, DCP, RTA and PTCP. These packets are directly forwarded to the registered callback in ICSS-EMAC (using rxRTCallBack). And the Queues 2 and 3 are forwarded to TCP/IP. Profinet FWHAL and stack also uses the TX/RX APIs available in the ICSS-EMAC for transmission/reception of packets like PTCP, LLDP, etc. More info on ICSS-EMAC can be found <a class="el" href="ICSS_EMAC.html">here</a>.</p>
<div class="image">
<img src="Profinet_Device_Priority_Queue_Decision_Block.PNG" alt=""/>
</div>
<h1><a class="anchor" id="autotoc_md687"></a>
OS Components</h1>
<p>This section describes the OS entities used by Profinet Device FWHAL.</p>
<h2><a class="anchor" id="autotoc_md688"></a>
Interrupts</h2>
<p>Profinet Device firmware generates the following interrupts.</p>
<p>8 Host Interrupts (Host Interrupts 2 through 9) are exported from the PRU_ICSSG internal INTC for signaling the device level interrupt controllers. PRU_EVTOUT0 to PRU_EVTOUT7 corresponds to these eight interrupts in the following table. Please check <a class="el" href="DRIVERS_PRUICSS_PAGE.html#PRUICSS_INTC">PRUICSS Interrupt Controller</a> section for more details.</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Host Interrupt </th><th>Description  </th></tr>
<tr>
<td>Frame Receive </td><td>PRU_EVTOUT0 </td><td>Notifies host when firmware has stored a frame in host receive queue  </td></tr>
<tr>
<td>PPM Frame Transmit Completion </td><td>PRU_EVTOUT1 </td><td>Raised when firmware has transmitted a PPM frame  </td></tr>
<tr>
<td>CPM Frame Receive </td><td>PRU_EVTOUT2 </td><td>On reception of CPM frame firmware raises this interrupt  </td></tr>
<tr>
<td>DHT </td><td>PRU_EVTOUT3 </td><td>Firmware notifies DHT event and PPM list toggle event to host through this interrupt  </td></tr>
<tr>
<td>PTCP </td><td>PRU_EVTOUT4 </td><td>Firmware notifies reception of RTSync frame  </td></tr>
<tr>
<td>Link Change </td><td>PRU_EVTOUT6 </td><td>Interrupt is raised when the link on Ethernet PHY comes up or goes down  </td></tr>
<tr>
<td>ISOM </td><td>PRU_EVTOUT7 </td><td>Interrupt is raised ISOM event occurs. Applicable for ISOM Interrupt mode only  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md689"></a>
Tasks</h2>
<table class="doxtable">
<tr>
<th>Task Function Name </th><th>Description  </th></tr>
<tr>
<td>PN_PTCP_task </td><td>PTCP delay measurement scheduling  </td></tr>
<tr>
<td>PN_PTCP_syncMonitorTask </td><td>PTCP sync monitor scheduling  </td></tr>
<tr>
<td>PN_IRT_legacyTask </td><td>Legacy startup mode scheduling  </td></tr>
<tr>
<td>PN_MRP_CPMTask </td><td>MRP Task to control flush mode of ICSS  </td></tr>
<tr>
<td>PN_tapWatchDog_task </td><td>Tap the ICSS WatchDog Timer  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md690"></a>
Semaphores</h2>
<table class="doxtable">
<tr>
<th>Name </th><th>Description  </th></tr>
<tr>
<td>ptcpStartSem </td><td>Indicates start of PTCP  </td></tr>
<tr>
<td>ptcpTriggerMeasurementSem </td><td>Triggers delay measurement  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md691"></a>
CPM/PPM Management</h1>
<p>Profinet FWHAL supports upto 8 PPMs and CPMs. These CPMs/PPMs are managed internally as two lists of type (<a class="el" href="structt__descList.html">t_descList</a>). In case of PPM, the descriptor buffer (pDescs of <a class="el" href="structt__descList.html">t_descList</a>) has two instances to maintain an <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#ga180104733d54734641dc00b6bdd160c8">ACTIVE_LIST</a> and <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#gaf6c862b1dee7c2c657c7e9e39f74ab1f">SHADOW_LIST</a> of buffers. Any data update to the PPM descriptors happens only on the <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#gaf6c862b1dee7c2c657c7e9e39f74ab1f">SHADOW_LIST</a>. This data is picked up by the PRU after a list toggle (<a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga3b219787388ef41498be3fc993e253bc">PN_togglePpmList</a>), which is currently done in the <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga102b5e90c7cfafefad05bfe543a9efe2">PN_insPpmList</a>. In the PPM descritor list, at any time the descriptors are sorted by port and phase, which is done by an internal API (<a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga6bc755dd1be94926e44ec71dc5e295d5">PN_writeSortedList</a>). CPM does not have the concept of Shadow and Active list. The API definitions can be found <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md692"></a>
Initialization</h2>
<p>The initialization of the Profinet system, lists and buffers are done in <a class="el" href="iPNDrv_8h.html#afb6314abeb4db734f83ff6dda191bccc">PN_initDrv</a>. All the OS related initializations are done in <a class="el" href="iPnOs_8h.html#a9620063edc831b064d9a2d74c6701f9a">PN_initOs</a>.</p>
<p>Taking a deeper look at <a class="el" href="iPNDrv_8h.html#afb6314abeb4db734f83ff6dda191bccc">PN_initDrv</a>, it initializes the following (in order of execution):</p><ul>
<li>Sets the Port 1 and Port 2 MACs in PRU memory</li>
<li>Sets the Compensation value - <a class="el" href="group__PN__PHASE__MANAGEMENT.html#gae37d0ecb3ccb83bb726a8f1db10024c4">PN_setCompensationValue</a></li>
<li>Calls <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga2429517c1fd9137ec247798fd8ecb8e8">PN_initRtcDrv</a><ul>
<li>Initializes and clears the CPM/PPM lists (<code>PN_initLists</code> initializes the <a class="el" href="structt__descList.html">t_descList</a> and <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gab9dbed95425e8f5ef3263dfc1efcc705">PN_clearList</a>)</li>
<li>Sets the base clock - <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#ga39d89dc11b400e2ca516a68ba437b4d9">PN_setBaseClock</a></li>
<li>Initializes the Profinet Interrupts (<a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gac201da1f145f5f79ac6cd3791ec3dfff">PN_cpmIsrHandler</a>, <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gab293eff8169194e785fd0cb225e9353a">PN_ppmIsrHandler</a> and <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga5b375b756b5afe4ff95188e446038ace">PN_dhtIsrHandler</a>)</li>
</ul>
</li>
<li>Initializes PTCP - <a class="el" href="group__PN__PTCP.html#ga019f5adfcc204167f8d59d41656bfa86">PN_PTCP_init</a></li>
<li>Loads the static tables</li>
<li>Writes the Profinet firmware to the PRU memory, and checks for correct version</li>
<li>Initialize both ports in <a class="el" href="group__PN__MRP.html#ga22b7cf9459e149feb38a5c3ead8f5b68">FORWARDING</a> state (for <a class="el" href="PROFINET_DEVICE_FWHAL.html#PROFINET_DEVICE_MRP">Media Redundancy Protocol (MRP)</a>)</li>
</ul>
<p>Once <a class="el" href="iPNDrv_8h.html#afb6314abeb4db734f83ff6dda191bccc">PN_initDrv</a> and <a class="el" href="iPnOs_8h.html#a9620063edc831b064d9a2d74c6701f9a">PN_initOs</a> is done, the driver memory (descriptor buffers) have to be initialized. This is done by the API <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gaced3df96f1b015ca9247de7055590c9f">PN_cfgRtcMem</a>. This API initializes two things :</p><ol type="1">
<li>The driver memory blocks ppmBlock0, ppmBlock1 and cpmBlock (using <code>PN_initRtcBuffs</code>).</li>
<li>Internal structure storing the Profinet configuration (currPN of <a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>). This structure stores the maximum size of CPM/PPM, number of ARs supported and the base structure for PPM/CPM (<a class="el" href="structt__rtcPacket.html">t_rtcPacket</a>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md693"></a>
Establishing a connection</h2>
<p>Whenever a connection has to be established, the stack should update the connection data in the internal driver lists. This can be done using the APIs <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga102b5e90c7cfafefad05bfe543a9efe2">PN_insPpmList</a> and <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga9ebdee50d464337c1bcddd6321c3eeaa">PN_insCpmList</a>. For configuring the CPM/PPM lists, the stack has to first allocate a buffer (in the driver). This can be done using <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gae4c22e6a13c4bddcb5609f8b50c3fdd6">PN_allocPkt</a>. This initializes the packet input to the API, finds a free slot in the list (ppmPkts/cpmPkts of currPN of <a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>) and allocates a particular block <a class="el" href="structt__ppmBlock.html">t_ppmBlock</a> or <a class="el" href="structt__cpmBlock.html">t_cpmBlock</a> to the buffer.</p>
<h3><a class="anchor" id="autotoc_md694"></a>
Establishing a PPM connection</h3>
<p>Once the buffer is allocated, the stack can update the data in the structure (<a class="el" href="structt__rtcPacket.html">t_rtcPacket</a>) and call <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga102b5e90c7cfafefad05bfe543a9efe2">PN_insPpmList</a> to update the driver with the new data. This API sorts the <a class="el" href="structt__descList.html">t_descList</a> in terms of Port and Phase and requests the PRU to toggle the list (i.e., shadow to active list) using <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga3b219787388ef41498be3fc993e253bc">PN_togglePpmList</a> . When the PRU is ready, it toggles the list and sends out the new data (also fires the <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gab293eff8169194e785fd0cb225e9353a">PN_ppmIsrHandler</a>).</p>
<dl class="section note"><dt>Note</dt><dd>All data updates are done to the <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#gaf6c862b1dee7c2c657c7e9e39f74ab1f">SHADOW_LIST</a> only.</dd></dl>
<h3><a class="anchor" id="autotoc_md695"></a>
Establishing a CPM connection</h3>
<p>Similar to establishing a connection in PPM, <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga9ebdee50d464337c1bcddd6321c3eeaa">PN_insCpmList</a> is used to update the driver with a new connection. As the concept of Shadow lists is not present in CPM, the data is directly inserted to the list using <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#ga7b7a5419e7032b80deeb352a320508b6">PN_writeCpmDesc</a>. It also locks the PROC buffer (PROC buffer is explained in <a class="el" href="PROFINET_DEVICE_FWHAL.html#PROFINET_DEVICE_TRIPLE_BUFFER_MANAGEMENT">Triple Buffer Management</a>).</p>
<h2><a class="anchor" id="autotoc_md696"></a>
Updating CPM/PPM data</h2>
<p>Once the connection is established, the CPM and PPM data can be updated using the Triple Buffer Scheme. Read more about it <a class="el" href="PROFINET_DEVICE_FWHAL.html#PROFINET_DEVICE_TRIPLE_BUFFER_MANAGEMENT">here</a>.</p>
<h1><a class="anchor" id="PROFINET_DEVICE_TRIPLE_BUFFER_MANAGEMENT"></a>
Triple Buffer Management</h1>
<p>The Triple Buffer scheme ensures that the stack or PRU always finds a buffer to update. In case of PPM, the stack is the Producer and PRU consumes this, and in case of CPM, the PRU is the producer and Stack consumes this. Each CPM/PPM descriptor has three buffers associated with it, these buffers are indexed by three pointers - next, last and proc (in <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a>). There is also a validLast flag in the same structure that indicates there is an update in data (CPM or PPM, set correspondingly by PRU or stack).</p><ul>
<li>NEXT<ul>
<li>Index to the next available buffer.</li>
<li>The stack/PRU writes to this buffer whenever there is new data.</li>
</ul>
</li>
<li>LAST<ul>
<li>Index to the last updated buffer.</li>
<li>At any point of time, this buffer contains the latest data to be consumed (CPM) or produced (PPM).</li>
</ul>
</li>
<li>PROC<ul>
<li>Index to the buffer being currently processed.</li>
<li>In case of CPM, this indicates the buffer which is currently being consumed by the stack. This buffer will be locked by the stack (using <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gab34c216e6c3035a97527a599503715a4">PN_cpmBuffLock</a>). This indicates to PRU that the PROC buffer cannot be written. The PRU ping pongs between NEXT and LAST buffer to update data.</li>
<li>In case of PPM, this indicates the buffer being send by the PRU. The stack updates the NEXT and LAST buffer in ping pong fashion until the PRU is ready to send updated data (by <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaa037338a3b8ea628bebe61ed4db30c8b">PN_checkLastPPM</a>)</li>
</ul>
</li>
<li>validLast<ul>
<li>In case of CPM, the PRU sets this flag whenever there is updated data in the LAST buffer. The stack calls <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gacd72037e79577f87ea28e058faebebc5">PN_nextCpmRdy</a> when it is ready to consume a new packet, and checks this flag for any new data.</li>
<li>In case of PPM, when the stack has updated data in the LAST buffer, this flag is set (<a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">PN_relPpmBuff</a>). When the PRU is ready to take a new buffer, <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaa037338a3b8ea628bebe61ed4db30c8b">PN_checkLastPPM</a> is called and the new PPM is produced by PRU.</li>
</ul>
</li>
</ul>
<p>The API definitions can be found <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md697"></a>
PPM Triple buffer management</h2>
<p>In case of PPM, the stack is the Producer, and PRU consumes it to send it out on the wire.</p>
<p>When the stack has a new PPM to be updated to send, it calls the API <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaf6211b517bbfc9c142d974c3d3b1387e">PN_getPpmBuff</a>, which returns the a free buffer in the triple buffer(NEXT). The stack then starts updating data in NEXT (marked by grey box in the following diagram).</p>
<div class="image">
<img src="Profinet_Device_ppm_triplebuffer_1.png" alt=""/>
<div class="caption">
Figure 1</div></div>
<p>When the stack has completed updating data (marked by Green box in the following diagram to NEXT, it calls the API <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">PN_relPpmBuff</a>. At this point, the LAST index and NEXT index is swapped. This means that the LAST data (previous) is discarded and we have a new LAST data (the validLast flag is set). If the stack wants to further update new data, the NEXT pointer is again used.</p>
<div class="image">
<img src="Profinet_Device_ppm_triplebuffer_2.png" alt=""/>
<div class="caption">
Figure 2</div></div>
<p>Next, when the PRU is ready to update data (which is send on the wire), <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaa037338a3b8ea628bebe61ed4db30c8b">PN_checkLastPPM</a> is triggered. At this point, the PROC and LAST indexes are swapped. This enables PRU to send the LAST data, which is the latest available PPM data at any point of time. The validLast flag is cleared, which indicates the PRU that there is no update in the data. Afer this, the stack has NEXT and LAST buffers to update future data (in a ping pong fashion) as shown in Figure 1.</p>
<div class="image">
<img src="Profinet_Device_ppm_triplebuffer_3.png" alt=""/>
<div class="caption">
Figure 3</div></div>
<h2><a class="anchor" id="autotoc_md698"></a>
CPM Triple buffer management</h2>
<p>In case of CPM, the PRU is the Producer, and the stack consumes it to use the data.</p>
<p>The stack always reads from the PROC buffer and also has it locked using <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gab34c216e6c3035a97527a599503715a4">PN_cpmBuffLock</a>. The PRU never writes into this buffer. Figure 4 shows that the PRU is writing in NEXT buffer, while PROC (Buffer 2) is locked by the stack.</p>
<div class="image">
<img src="Profinet_Device_cpm_triplebuffer_1.png" alt=""/>
<div class="caption">
Figure 4</div></div>
<p>When the PRU has new data to be written, the NEXT and LAST indexes are swapped. This indicates that LAST is pointed to the latest available data (to be consumed by the stack). If the PRU has updated data to be written, it uses the NEXT buffer. The PRU keeps continuing in the loop i.e., switching the NEXT and LAST buffers in a ping pong fashion till the stack consumes the LAST data.</p>
<div class="image">
<img src="Profinet_Device_cpm_triplebuffer_2.png" alt=""/>
<div class="caption">
Figure 5</div></div>
<p>When the stack is ready to consume new data, it calls the API <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga0f7c48193cc9e2e72d208925fe3d7589">PN_getLastCpm</a>. A swap of LAST and PROC indexes in done here. This indicates the stack consumes the latest data available at any point of time. The stack also should lock the buffer using <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gab34c216e6c3035a97527a599503715a4">PN_cpmBuffLock</a>. At this point PRU starts updating any new data in the NEXT buffer.</p>
<div class="image">
<img src="Profinet_Device_cpm_triplebuffer_3.png" alt=""/>
<div class="caption">
Figure 6</div></div>
<h1><a class="anchor" id="PROFINET_DEVICE_MRP"></a>
Media Redundancy Protocol (MRP)</h1>
<p>A state machine is implemented by <code>PN_MRP_CPMTask</code> to implement MRP. If a break is detected in the topology, this state machine switches to a state where the PRU sends PPM on both ports. It is also made sure that the FDB for both the ports are cleared. Once all the CPMs learn the correct port number (port of <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a>), the flush mode is deactivated. The API definitions are present <a class="el" href="group__PN__MRP.html">here</a>.</p>
<dl class="section note"><dt>Note</dt><dd>To enable MRP, it is required to set the macro <code>MRP_SUPPORT</code> in <code>${SDK_INSTALL_PATH}/source/industrial_comms/profinet_device/RT_MRP/pnDrvConfig.h</code> file</dd></dl>
<h2><a class="anchor" id="autotoc_md699"></a>
MRP State Machine</h2>
<p>The MRP state machine has 5 states defined by <a class="el" href="group__PN__MRP.html#ga26676c1e30ce84e443879a4bfdd79486">tMrpStates</a>. The state machine flow chart is shown in Figure 7.</p>
<div class="image">
<img src="Profinet_Device_mrp_state.png" alt=""/>
<div class="caption">
Figure 7</div></div>
<ul>
<li><a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ab4bf32501411120990cd6c31345939c4">MRPREADY</a> : At initialization the state machine is set to this. This is an idle loop that does nothing, and indicates all links are OK.</li>
<li><a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486a6ee60ba03af3ab68d8970a6947d6b440">MRPENTER</a> : Whenever a link break is detected. The stack calls <a class="el" href="group__PN__MRP.html#ga1f4b402ad72e922878147e4343ba7e11">PN_enterFlushMode</a> to switch the state machine to MRPENTER. In this state, the port(port of <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a>) of all the CPM packets are set to 0(invalid state), and the PRU is indicated to switch to Flush mode.</li>
<li><a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486a5e4d4b9c059fd9223f1a4fff9a1c685c">MRPWAIT</a> : This state is used to switch between <a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ac97fa621aaa197a50a3e0d2de1d4149f">MRPCHECK</a> and <a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486a5e4d4b9c059fd9223f1a4fff9a1c685c">MRPWAIT</a> with a sleep.</li>
<li><a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ac97fa621aaa197a50a3e0d2de1d4149f">MRPCHECK</a> : This state checks if the port of all CPMs are learned, if yes it goes to <a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ad5ab3076ef75af9f34a54c182b59aa52">MRPEXIT</a>, else sleep(going to <a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486a5e4d4b9c059fd9223f1a4fff9a1c685c">MRPWAIT</a>).</li>
<li><a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ad5ab3076ef75af9f34a54c182b59aa52">MRPEXIT</a> : Resets the state machine back to <a class="el" href="group__PN__MRP.html#gga26676c1e30ce84e443879a4bfdd79486ab4bf32501411120990cd6c31345939c4">MRPREADY</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md700"></a>
Profinet IRT Legacy Startup Support</h1>
<p>The Profinet IRT Legacy startup feature is implemented using a state machine <code>PN_IRT_legacyTask</code>.</p>
<p>Before a connection is established(i.e., <code>RTC_CPM_STATUS_OFFSET</code> is not set to <code>RTC_CPM_RUN</code>), if legacy mode is enabled, the driver configures a PPM packet to be send in Green period. The API definitions are present <a class="el" href="group__PN__IRT__LEGACY.html">here</a>.</p>
<dl class="section note"><dt>Note</dt><dd>To enable Legacy startup, it is required to set the macro <code>IRT_LEGACY_STARTUP_SUPPORT</code> in <code>${SDK_INSTALL_PATH}/source/industrial_comms/profinet_device/IRT/pnDrvConfig.h</code> file</dd></dl>
<h2><a class="anchor" id="autotoc_md701"></a>
Profinet IRT Legacy Startup State Machine</h2>
<p>The IRT Legacy Startup state machine has 4 states defined by <a class="el" href="group__PN__IRT__LEGACY.html#gaafe4a9572aa436edc740c4c05144ceac">tLegStates</a>. The state machine flow charts is shown in Figure 8.</p>
<div class="image">
<img src="Profinet_Device_irt_legstate.png" alt=""/>
<div class="caption">
Figure 8</div></div>
<ul>
<li><a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceacada78431911546de84fc863ba878eb629">NOINIT</a> : At initialization the state machine is set to <a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceacada78431911546de84fc863ba878eb629">NOINIT</a>. This state waits for the base driver to be ready, and then switches the state machine to <a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceaca6564f2f3e15be06b670547bbcaaf0798">READY</a>.</li>
<li><a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceaca6564f2f3e15be06b670547bbcaaf0798">READY</a> : This state is an idle loop, which waits for PPM packet to be initialized.</li>
<li><a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceaca20614c5e0d41d65e293a6627f3a2a5b6">SENDPPM</a> : When the PPM packet is ready, the application sets the state to <a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceaca20614c5e0d41d65e293a6627f3a2a5b6">SENDPPM</a> (by callback function <code>irtLegStateCall</code>. When this is done, the driver will send out the latest PPM data from <code>pLegPkt</code> (which is set by the callback <code>irtLegPktCall</code>). The driver calls the callback in <a class="el" href="iPNLegacy_8h.html#a39ee11c667fc3ece8dca6ac88e7326ff">insPpmList</a> if the input param to the API has legMode configured). The packet is send out in intervals, till the connection is established.</li>
<li><a class="el" href="group__PN__IRT__LEGACY.html#ggaafe4a9572aa436edc740c4c05144ceaca781ad2788df9e25c59a70894c7832096">ABORT</a> : Error state.</li>
</ul>
<h1><a class="anchor" id="autotoc_md702"></a>
Phase Management</h1>
<p>Every cycle in Profinet IRT is split into a RED and GREEN period. The driver has APIs to configure these periods, which is mostly done during establishment of connection. GREEN period can be further classified into Green steady period and Yellow period. If a packet has to be transmitted during Yellow period, the driver has to check if the packet can be send out in the remaining time left. Otherwise it is send out in the next green period. The API definitions are present <a class="el" href="group__PN__PHASE__MANAGEMENT.html">here</a>.</p>
<div class="image">
<img src="Profinet_Device_phase_mgmnt.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md703"></a>
Implementation</h2>
<ul>
<li>The phases are mapped to profiles(which holds the information regarding RX start of green period and TX start of green period). There can be 5 profiles each for a port, which is configured by <a class="el" href="group__PN__PHASE__MANAGEMENT.html#gacc691722f2ec42a7ab6b505a941cdcb4">PN_setProfile</a>.</li>
<li>The 16 phases in Profinet can be mapped to any of these Profiles using <a class="el" href="group__PN__PHASE__MANAGEMENT.html#ga2eb0aafa46518a9a98a89c8d4fd6c5d1">PN_mapPhaseToProfile</a>. All this configuration should be done during the connection establishment. -The enabling/disabling of Phase management is based on the RTC3 port state. Phase management is disabled if RTC3 port state is <a class="el" href="iPNDrv_8h.html#a29e413f6725b2ba32d165ffaa35b01e5">OFF</a>, and enabled if it's <a class="el" href="iPNDrv_8h.html#a35f69a612b07bbf1de53bbbd8d877c09">RUN</a> or <a class="el" href="iPNDrv_8h.html#a1965eaca47dbf3f87acdafc2208f04eb">UP</a>.</li>
<li>The stack also has to configure the Max Bridge delay(<a class="el" href="group__PN__PHASE__MANAGEMENT.html#gada00ccf94d8a08c52892fdaa2b9e6391">PN_setMaxBridgeDelay</a>), Max Line RX Delay(<a class="el" href="group__PN__PHASE__MANAGEMENT.html#gabbe2b9f3fe838378c79690e76f394667">PN_setMaxLineRxDelay</a>), and the Yellow period(<a class="el" href="group__PN__PHASE__MANAGEMENT.html#ga3b75caff31790f78ac8835306663a401">PN_setYellowPeriod</a>). This information is available from the GSD file.</li>
<li>The RED guard also should be set by the stack, which defines a range of valid Red frame IDs(<a class="el" href="group__PN__PHASE__MANAGEMENT.html#ga20ab85d2418e524acd6be46241fef011">PN_setRedGuard</a>).</li>
<li>The API <a class="el" href="group__PN__PHASE__MANAGEMENT.html#ga71b7d83b962c1b6acc5f0edb9b2e247a">PN_setRtc3PortStatus</a> can be used by the stack to set the Port status to enable RTC3 on the port(valid states <a class="el" href="iPNDrv_8h.html#a35f69a612b07bbf1de53bbbd8d877c09">RUN</a>, <a class="el" href="iPNDrv_8h.html#a1965eaca47dbf3f87acdafc2208f04eb">UP</a> and <a class="el" href="iPNDrv_8h.html#a29e413f6725b2ba32d165ffaa35b01e5">OFF</a>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md704"></a>
PTCP</h1>
<p>The API definitions are present <a class="el" href="group__PN__PTCP.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md705"></a>
Implementation</h2>
<p>PTCP is implemented in the PRU and PTCP driver. It mainly has two parts</p>
<h3><a class="anchor" id="autotoc_md706"></a>
SYNC handling</h3>
<p>PTCP has an ISR <a class="el" href="group__PN__PTCP.html#ga949d3bdb91a7f44b5e0ceed7b798f281">PN_PTCP_isrHandler</a> which is triggered when a SYNC packet is received from the PRU. The ISR internally calls an important API <a class="el" href="group__PN__PTCP.html#gaa133e3ecb79d739bb1ea1bd6148f2715">PN_PTCP_syncHandling</a> which calculates the deltaT between the master and slave, and according initiates the clock adjustment process. There is also a filter implemented which makes sure the compensation is done only once the deltaT is stable. The driver also maintains a task <code>PN_PTCP_syncMonitorTask</code> to monitor if there is a sync timeout.</p>
<h3><a class="anchor" id="autotoc_md707"></a>
Delay Handling</h3>
<p>Another task <code>PN_PTCP_task</code> does the handling of delays (cable delay, line delay etc.). This task sends out multiple delay requests in a particular interval, and processes the delay responses(<a class="el" href="group__PN__PTCP.html#ga902d4181e53da39c31c05e8f3a3f3bcd">PN_PTCP_delayMeasurement</a>). The calculated line delays (<a class="el" href="structdeviceDelays__t.html">deviceDelays_t</a>) and port delays (<a class="el" href="structptcpPortDelayVal__t.html">ptcpPortDelayVal_t</a>) are stored in the internal structures.</p>
<h2><a class="anchor" id="autotoc_md708"></a>
Integrating with the stack</h2>
<p>The driver provides two main callbacks that can be used by the stack for certain even triggers. They are <code>ptcpSyncStatusCall</code> and <code>ptcpDelayUpdateCall</code> (which can be registered by calling the APIs <a class="el" href="group__PN__PTCP.html#ga5ef2888414f341f7f2cfe821b79f2b0c">PN_PTCP_registerSyncStatusCall</a> and <a class="el" href="group__PN__PTCP.html#ga6e47ee54216c9c001b25ca3c5b1477ca">PN_PTCP_registerDelayUpdateCall</a>). The <code>ptcpDelayUpdateCall</code> is triggered whenever there is any update in the delays calculated. The <code>ptcpSyncStatusCall</code> is used by Sync to notify any update in the SYNC state. It also indates error events like <a class="el" href="group__PN__PTCP.html#gga65a2860bf2747e33eb92949aca1f2d24aa0efbe3de6681be67e24e7a121048460">TAKEOVER_TIMEOUT</a> and <a class="el" href="group__PN__PTCP.html#gga65a2860bf2747e33eb92949aca1f2d24a58da16289d76573f3fdde8c127be69d5">SYNC_TIMEOUT</a>.</p>
<h1><a class="anchor" id="autotoc_md709"></a>
Isochronous Mode</h1>
<p>The firmare supports generation of two ISOM events in a network cycle. <a class="el" href="group__PN__ISOM.html">Isochronous Mode APIs</a> can be used to to configure the firmware.</p>
<h2><a class="anchor" id="autotoc_md710"></a>
Implementation</h2>
<p>The ISOM implementation supports configuration of two types of ISOM events: Interrupt mode and GPIO mode.</p>
<ul>
<li>Interrupt Mode : Interrupts will be generated at configured intervals. The details of the Hardware interrupt (Interrupt number and ISR) need to be configured in the ISOM structure in PN handle. Firmware uses SYNC1_OUT_EVENT to trigger the intterupt. By default this event is mapped to PRU_EVTOUT7.</li>
<li>GPIO Mode : In this mode, the firware is configured to generate signals at specific intervals. The signals are available at the pin prX_edc_sync1_out. Current implementation supports only single pulse width configuration for the signals. Pulse width used in latest configuration is taken.</li>
</ul>
<h1><a class="anchor" id="autotoc_md711"></a>
DCP Filter</h1>
<p>In a chain of devices, during startup the first device receives a storm of Ident Requests. As all these packets go to ARM, there is a possibility that the device might lose the Ident Req which is meant for the device. To avoid this situation, the DCP Filter can be used. This ensures that only the Ident Request packet with the configured station name is forwarded to ARM. A maximum of 8 characters is compared by the firmware(last 8 characters). If the length of station name is set to 0, this indicates the DCP Filter is not in use. The API definitions are present <a class="el" href="group__PN__DCP__FILTER.html">here</a>.</p>
<h1><a class="anchor" id="autotoc_md712"></a>
Multicast Filter Tables</h1>
<p>The stack has to configure the Multicast filter table. This is done by the API <a class="el" href="group__PN__FILTER__TABLE.html#gac2bb99dc02c60a616be4ad35d80c4991">PN_setStaticFilterTable</a>. There are two tables, <a class="el" href="group__PN__MRP.html#ga22b7cf9459e149feb38a5c3ead8f5b68">FORWARDING</a> table and <a class="el" href="group__PN__MRP.html#gabe4c463bf79e1012602b9a0e2b40f29f">BLOCKING</a> table. The Multicast addresses can be configured to function in one of these states:</p><ul>
<li><a class="el" href="iPNDrv_8h.html#a5281b06c92fd6e90539122a3ae1e55d3">NO_RCV_NO_FWD</a></li>
<li><a class="el" href="iPNDrv_8h.html#a422d42593362f3245a1c7ce6846a5fe3">RCV_NO_FWD</a></li>
<li><a class="el" href="iPNDrv_8h.html#a10745c564e1c7e6b1a0af0210d89c40e">NO_RCV_FWD</a></li>
<li><a class="el" href="iPNDrv_8h.html#aaef232969a9d9f42d1572def08633595">RCV_FWD</a></li>
</ul>
<p>The API definitions are present <a class="el" href="group__PN__FILTER__TABLE.html">here</a>.</p>
<h1><a class="anchor" id="autotoc_md713"></a>
Watchdog Timer</h1>
<p>Watchdog timer is used as a safety feature to monitor the application state and to turn off the PPM transmission after pre-defined interval if application is not responding. The watchdog will thereby protect the system from errors or faults by timeout or expiration. The expiration is used to initiate corrective action in order to keep the system in a safe state and restore normal operation based on configuration. Therefore, if the system is stable, the watchdog timer should be regularly reset or cleared to avoid timeout or expiration.</p>
<p>Application can use the API <a class="el" href="group__PN__WATCHDOG.html#gaa6e064ab1a0b2224834664ae1654b53e">PN_setWatchDogTimer</a> (defined in iPNDrv.c) to set the timeout value. Application needs to enable the <code>WATCHDOG_SUPPORT</code> macro in <code>${SDK_INSTALL_PATH}/source/industrial_comms/profinet_device/IRT/pnDrvConfig.h</code> or <code>${SDK_INSTALL_PATH}/source/industrial_comms/profinet_device/RT_MRP/pnDrvConfig.h</code> file to use this feature. By default the PROFINET Slave driver sets the timeout to 100ms (watchDogExpireDuration defined in iPndrv.h) using <code>PN_setWatchDogTimer(pnHandle, watchDogExpireDuration)</code>. The PN_tapWatchDog_task task defined in iPnOs.c resets the watchdog timer periodically.</p>
<p>This timeout is system dependent and is the responsibility of user to set the trigger frequency and the timeout. If watchdog timer expires, the firmware will stop all active PPM connections.</p>
<p>Application can check the expiry state of watchdog timer using WD_STATUS register in ICSS IEP. Bit 0 of WD_STATUS is PD_WD_STAT. An example is shown below.</p><ul>
<li>Condition for Active or disabled: 0x0001 == HW_RD_REG16(emacBaseAddr-&gt;prussIepRegs + CSL_ICSSIEP_WD_STATUS_REG)</li>
<li>Condition for Expired: 0x0000 == HW_RD_REG16(emacBaseAddr-&gt;prussIepRegs + CSL_ICSSIEP_WD_STATUS_REG)</li>
</ul>
<p>The API definitions are present <a class="el" href="group__PN__WATCHDOG.html">here</a>.</p>
<h1><a class="anchor" id="PROFINET_DEVICE_ADDITIONAL_REFERENCES"></a>
Additional References</h1>
<p>Please refer to below documents to understand more about Profinet Device on TI platforms and Profinet Device protocol specifications.</p>
<table class="doxtable">
<tr>
<th>Document </th><th>Description  </th></tr>
<tr>
<td><a href="https://www.ti.com/lit/pdf/spry252">PROFINET on TI's Sitara processors</a> </td><td>Application note by TI on the Profinet implementation on TI's Sitara Processors.  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md714"></a>
See also</h1>
<ul>
<li><a class="el" href="EXAMPLES_INDUSTRIAL_COMMS_PROFINET_DEVICE_DEMOS.html">Profinet Device Demos</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
