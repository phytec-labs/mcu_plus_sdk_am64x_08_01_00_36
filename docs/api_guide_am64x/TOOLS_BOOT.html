<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Booting Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_BOOT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Booting Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md779">Introduction</a></li>
<li class="level1"><a href="#autotoc_md780">Important files and folders</a></li>
<li class="level1"><a href="#autotoc_md781">Out2RPRC</a></li>
<li class="level1"><a href="#autotoc_md782">Multi-core Image Gen</a></li>
<li class="level1"><a href="#TOOLS_BOOT_SIGNING">Signing Scripts</a></li>
<li class="level1"><a href="#autotoc_md783">XIP Image Generator Tool</a></li>
<li class="level1"><a href="#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a></li>
<li class="level1"><a href="#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_boot"></a></p>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md779"></a>
Introduction</h1>
<p>This section describes the various tools that are used to create boot images for all the SDK applications</p>
<h1><a class="anchor" id="autotoc_md780"></a>
Important files and folders</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>multicoreImageGen/ </td><td>Tool to combine multiple RPRC into a single binary  </td></tr>
<tr>
<td>out2rprc/ </td><td>Tool to convert compiler generated ELF .out for a CPU to a compact and loadable binary representation, called RPRC.  </td></tr>
<tr>
<td>sbl_prebuilt/ </td><td>Pre-built secondary bootloader (SBL) images and flash configuration files for different supported EVMs, see also <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a>  </td></tr>
<tr>
<td>signing/ </td><td>Security signing scripts need to create boot images that can be booted by ROM bootloader (RBL)  </td></tr>
<tr>
<td>xipGen/ </td><td>Tool to split a RPRC file generated from <code>out2rprc</code> into two files containing non-XIP and XIP sections.  </td></tr>
<tr>
<td>uart_bootloader.py </td><td>Python script used to send the SBL and appimage binaries over UART using XMODEM protocol in UART boot mode  </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Python script used to flash SBL and applications to EVM flash using UART. See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for more details.  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md781"></a>
Out2RPRC</h1>
<ul>
<li>This tool converts the application executable (.out) into custom TI RPRC (.rprc) image - an image loadable by the secondary bootloader (SBL).</li>
<li>This tool strips out the initialized sections from the executable file (*.out) and places them in a compact format that the SBL can understand.</li>
<li>The output RPRC file is typically much smaller than the original executable (*.out) file.</li>
<li>The RPRC files are intermediate files in a format that is consumed by <code>MulticoreImageGen</code> tool that generates the final binary that is flashed (<code>*.appimage</code>)</li>
<li>The RPRC file format contains header to various sections in the executable like section run address, size and a overall header which mentions the number of sections and the start offset to the first section.</li>
<li>The RPRC magic word is <code>0x43525052</code> - which is ASCII equivalent for <code>RPRC</code></li>
<li>Shown below is the file header and section format for RPRC files.</li>
</ul>
<p> <style>div.image img[src="tools_rprc_format.png"]{width:40%}</style> </p><div class="image">
<img src="tools_rprc_format.png" alt=""/>
<div class="caption">
RPRC File Format</div></div>
<ul>
<li>In Windows, use the following command to convert application executable into RPRC image file <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/out2rprc</div>
<div class="line">out2rprc {input application executable file (.out) {output application rprc file (.rprc)}</div>
</div><!-- fragment --></li>
<li>In Linux, use <code>mono</code> to invoke this executable (see <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_MONO">Mono Runtime</a>) <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/out2rprc</div>
<div class="line">mono out2rprc.exe {input application executable file (.out) {output application rprc file (.rprc)}</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In windows, the out2rprc.exe has a dependency on .NET framework 3.5. Make sure that this is installed. You can check this via Control Panel -&gt; Programs and Features.</dd></dl>
<h1><a class="anchor" id="autotoc_md782"></a>
Multi-core Image Gen</h1>
<ul>
<li>This tool converts the RPRC files created for each CPU into a single combined multicore application image that can be booted by the secondary bootloader (SBL)</li>
<li>Shown below is the file format for multicore image files.</li>
</ul>
<p> <style>div.image img[src="tools_multicore_format.png"]{width:60%}</style> </p><div class="image">
<img src="tools_multicore_format.png" alt=""/>
<div class="caption">
Multi-core Image File Format</div></div>
<ul>
<li>The number of meta headers present is equal to the number of cores included.</li>
<li>The meta header magic word is <code>0x5254534D</code> - which is ASCII equivalent for <code>MSTR</code></li>
<li>In Windows or Linux, use the following command to convert RPRC images into a multicore <code>.appimage</code> file <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/multicoreImageGen</div>
<div class="line">MulticoreImageGen {ENDIAN} {DEV_ID} {Output image file (.appimage)} {core 1 id} {core 1 rprc file} [ {core n id} {core n rprc file} ... ]</div>
</div><!-- fragment --></li>
<li>In case of AM64X, <code>ENDIAN</code> should be <code>LE</code> and <code>DEV_ID</code> is <code>55</code>.</li>
<li>The various core ID to be used are as below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CORE  </th><th class="markdownTableHeadNone">CORE ID   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss0-0  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss0-1  </td><td class="markdownTableBodyNone">5   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss1-0  </td><td class="markdownTableBodyNone">6   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss1-1  </td><td class="markdownTableBodyNone">7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m4fss0-0  </td><td class="markdownTableBodyNone">14   </td></tr>
</table>
<h1><a class="anchor" id="TOOLS_BOOT_SIGNING"></a>
Signing Scripts</h1>
<ul>
<li>To run these scripts, one needs <code>openssl</code> installed as mentioned here, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_OPENSSL">OpenSSL</a></li>
<li>Signing scripts are a collection of scripts needed to sign the secondary bootloader (SBL) image as required by ROM bootloader (RBL).</li>
<li>The RBL requires the boot image (in this case SBL), to be signed always, even if we are not using secure boot.</li>
<li>Use the following command to sign the SBL image. <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">x509CertificateGen.ps1 -b {BOOTIMAGE_BIN_NAME} -o {BOOTIMAGE_NAME} -c R5 -l {SBL_RUN_ADDRESS} -k {BOOTIMAGE_CERT_KEY} -d DEBUG -j DBG_FULL_ENABLE -m SPLIT_MODE</div>
</div><!-- fragment --></li>
<li>In Windows, use powershell to execute the script file. <div class="fragment"><div class="line">powershell -executionpolicy unrestricted -command x509CertificateGen.ps1</div>
</div><!-- fragment --><ul>
<li>Here,<ul>
<li><code>SBL_RUN_ADDRESS</code> is <code>0x70000000</code></li>
<li><code>BOOTIMAGE_CERT_KEY</code> is <code>rom_degenerateKey.pem</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md783"></a>
XIP Image Generator Tool</h1>
<ul>
<li>This tool, splits a input RPRC application file, into two RPRC files,<ul>
<li>First RPRC file, containing non-XIP sections and the application entry point</li>
<li>Second RPRC file, containing XIP sections. Here, adjacent sections are merged into one section</li>
</ul>
</li>
<li>The final number of sections in both RPRC files taken together can be less than the sections in the input file due to section merging in the XIP RPRC file.</li>
</ul>
<p> <style>div.image img[src="tools_xip_gen.png"]{width:60%}</style> </p><div class="image">
<img src="tools_xip_gen.png" alt=""/>
<div class="caption">
XIP Image Generation Tool flow</div></div>
<ul>
<li>The non-XIP RPRC file should be flashed and booted via SBL as usual</li>
<li>The XIP RPRC file should be flashed via the SDK flash writer, using the command <code>--flash-xip</code>, the flash writer in this case will flash sections at the flash address mentioned in the RPRC section header.</li>
<li>To see the detailed options supported by the tool, run this tool with the option <code>--help</code>. Example, output in Windows is shown below,</li>
</ul>
<div class="fragment"><div class="line">&gt; cd {SDK_INSTALL_PATH}/tools/boot/xipGen</div>
<div class="line">&gt; xipGen.exe</div>
<div class="line"> </div>
<div class="line">  XIP Image Creation Tool  - (c) Texas Instruments 2021, created on Apr 19 2021</div>
<div class="line"> </div>
<div class="line">  Usage: xipGen [options]</div>
<div class="line"> </div>
<div class="line">  Description,</div>
<div class="line">  This tool, splits a input RPRC application file, into two RPRC files,</div>
<div class="line">  - First RPRC file, containing non-XIP sections. The application entry point is assumed</div>
<div class="line">      to be in non-XIP region.</div>
<div class="line">  - Second RPRC file, containing XIP sections. The RPRC entry point is set to 0 and</div>
<div class="line">      adjacent XIP sections are merged</div>
<div class="line"> </div>
<div class="line">  Note, the final number of sections in both RPRC files taken together can be less</div>
<div class="line">  than the sections in the input file due to section merging in the XIP RPRC file.</div>
<div class="line"> </div>
<div class="line">  The non-XIP RPRC file should be flashed and booted via SBL as usual</div>
<div class="line"> </div>
<div class="line">  The XIP RPRC file should be flashed via the SDK flash writer, the flash writer will</div>
<div class="line">  flash sections at the flash address mentioned in the RPRC sections</div>
<div class="line"> </div>
<div class="line">  Options,</div>
<div class="line">  --input, -i : input RPRC file,</div>
<div class="line">  --output, -o : output RPRC file of non-XIP sections,</div>
<div class="line">  --output-xip, -x : output RPRC file of XIP sections,</div>
<div class="line">  --flash-start-addr, -f : XIP flash address space start, specified in hex. If not specified 0x60000000 is used</div>
<div class="line">  --flash-size, -s : XIP flash address space size in units of mega bytes, specified as integer. If not specified 256 MB is used</div>
<div class="line">  --verbose, -v : Verbose prints are enabled during the tool execution</div>
<div class="line">  --help, -h : Shows this help</div>
</div><!-- fragment --><h1><a class="anchor" id="UART_BOOTLOADER_PYTHON_SCRIPT"></a>
UART Bootloader Python Script</h1>
<ul>
<li>This script is used in UART boot mode for sending the SBL and appimage binaries to the EVM via UART using XMODEM protocol</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Booting via UART is slow, but is useful if application loading via CCS or OSPI boot is not an option</li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and UART cable connected as shown in <a class="el" href="EVM_SETUP_PAGE.html#EVM_CABLES">Cable Connections</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a>.</li>
<li><b>POWER ON the EVM</b></li>
<li>To confirm that the board is in UART boot mode, open the UART terminal and confirm that you see the character 'C' getting printed on the console every 2-3 seconds.</li>
<li>Now close the terminal. This is important as the script won't be able to function properly if the UART terminal is open.</li>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p COM&lt;x&gt; --bootloader=sbl_prebuilt/{board}/sbl_uart.release.tiimage --file=&lt; path to multicore appimage of application binary &gt;</div>
</div><!-- fragment --></li>
<li>When you execute this, the script first sends the uart bootloader, and then the multicore appimage</li>
<li>After the multicore appimage is successfully parsed, the uart bootloader sends an acknowledgment to the script and waits for 5 seconds before running the application binary</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal within 5 seconds to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent <div class="fragment"><div class="line">Sending the UART bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage ...</div>
<div class="line">Sent bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage of size 243975 bytes in 23.94s.</div>
<div class="line"> </div>
<div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] Application load SUCCESS !!!</div>
<div class="line">Connect to UART in 5 seconds to see logs from UART !!!</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="LINUX_APPIMAGE_GEN_TOOL"></a>
Linux Appimage Generator Tool</h1>
<ul>
<li>This tool generates a Linux Appimage by taking the Linux binaries (ATF, OPTEE, SPL) as input and generates a Linux appimage containing the input Linux binaries.</li>
<li>The input file location can be mentioned in the <code>config.mak</code> file located at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen<ul>
<li><code>PSDK_LINUX_PREBUILT_IMAGES=/board-support/prebuilt-images</code></li>
</ul>
</li>
<li>The input file names for ATF, OPTEE and SPL can also be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Input linux binaries</code><br  />
 <code>ATF_BIN_NAME=bl31.bin</code><br  />
 <code>OPTEE_BIN_NAME=bl32.bin</code><br  />
 <code>SPL_BIN_NAME=u-boot-spl.bin-am64xx-evm</code><br  />
</li>
</ul>
</li>
<li>The load address for ATF, OPTEE and SPL need to be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Linux image load address</code><br  />
 <code>ATF_LOAD_ADDR=0x0701a0000</code><br  />
 <code>OPTEE_LOAD_ADDR=0x9e800000</code><br  />
 <code>SPL_LOAD_ADDR=0x80080000</code><br  />
</li>
</ul>
</li>
<li>The output appimage name can be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Output appimage name</code><br  />
 <code>LINUX_BOOTIMAGE_NAME=linux.appimage</code><br  />
</li>
</ul>
</li>
<li>Run the makefile at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen to generate the Linux appimage<ul>
<li>For Windows <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">gmake -s all</div>
</div><!-- fragment --></li>
<li>For Linux <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">make -s all</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>The Linux appimage wil be generated at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen after running the makefile </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
