<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: bootloader_soc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bootloader__soc_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bootloader_soc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="bootloader__soc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__CoreBootInfo.html">Bootloader_CoreBootInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information about a core specific to the AM64x SOC.  <a href="structBootloader__CoreBootInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa275163c52f8cee1e1c96b323c38c163"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#aa275163c52f8cee1e1c96b323c38c163">Bootloader_socCpuRequest</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:aa275163c52f8cee1e1c96b323c38c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request for a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#aa275163c52f8cee1e1c96b323c38c163">More...</a><br /></td></tr>
<tr class="separator:aa275163c52f8cee1e1c96b323c38c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff97fe5ae5893a01813ea264f6af4ad"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#afff97fe5ae5893a01813ea264f6af4ad">Bootloader_socCpuRelease</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:afff97fe5ae5893a01813ea264f6af4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#afff97fe5ae5893a01813ea264f6af4ad">More...</a><br /></td></tr>
<tr class="separator:afff97fe5ae5893a01813ea264f6af4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca6ca3d5d169d20309abe96cbcbf3b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#acca6ca3d5d169d20309abe96cbcbf3b3">Bootloader_socCpuSetClock</a> (uint32_t cpuId, uint32_t cpuHz)</td></tr>
<tr class="memdesc:acca6ca3d5d169d20309abe96cbcbf3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the clock of a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#acca6ca3d5d169d20309abe96cbcbf3b3">More...</a><br /></td></tr>
<tr class="separator:acca6ca3d5d169d20309abe96cbcbf3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250d95e4809165b42a2e00e65deb89b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#af250d95e4809165b42a2e00e65deb89b">Bootloader_socCpuGetClock</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:af250d95e4809165b42a2e00e65deb89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clock of a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#af250d95e4809165b42a2e00e65deb89b">More...</a><br /></td></tr>
<tr class="separator:af250d95e4809165b42a2e00e65deb89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f77ae23106afbd7173af93961aa8a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a83f77ae23106afbd7173af93961aa8a3">Bootloader_socCpuGetClkDefault</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:a83f77ae23106afbd7173af93961aa8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default clock of a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#a83f77ae23106afbd7173af93961aa8a3">More...</a><br /></td></tr>
<tr class="separator:a83f77ae23106afbd7173af93961aa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab648751ddc094ceb2e0e05e33f179829"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#ab648751ddc094ceb2e0e05e33f179829">Bootloader_socCpuPowerOnReset</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:ab648751ddc094ceb2e0e05e33f179829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do power-on-reset of a particular CPU in the AM64x SOC.  <a href="bootloader__soc_8h.html#ab648751ddc094ceb2e0e05e33f179829">More...</a><br /></td></tr>
<tr class="separator:ab648751ddc094ceb2e0e05e33f179829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc373fa0be1c31e324a84a6461805189"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#afc373fa0be1c31e324a84a6461805189">Bootloader_socCpuResetRelease</a> (uint32_t cpuId, uintptr_t entryPoint)</td></tr>
<tr class="memdesc:afc373fa0be1c31e324a84a6461805189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a particular CPU in the AM64x SOC from reset.  <a href="bootloader__soc_8h.html#afc373fa0be1c31e324a84a6461805189">More...</a><br /></td></tr>
<tr class="separator:afc373fa0be1c31e324a84a6461805189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdae485b83313a66ff7aca33c6b2e01"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a3fdae485b83313a66ff7aca33c6b2e01">Bootloader_socCpuResetReleaseSelf</a> ()</td></tr>
<tr class="memdesc:a3fdae485b83313a66ff7aca33c6b2e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release self CPU in the AM64x SOC from reset.  <a href="bootloader__soc_8h.html#a3fdae485b83313a66ff7aca33c6b2e01">More...</a><br /></td></tr>
<tr class="separator:a3fdae485b83313a66ff7aca33c6b2e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5353c3c4076dd7b033eb522fed49a020"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a5353c3c4076dd7b033eb522fed49a020">Bootloader_socCpuSetEntryPoint</a> (uint32_t cpuId, uintptr_t entryPoint)</td></tr>
<tr class="memdesc:a5353c3c4076dd7b033eb522fed49a020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set entry point for self CPU in the AM64x SOC from reset.  <a href="bootloader__soc_8h.html#a5353c3c4076dd7b033eb522fed49a020">More...</a><br /></td></tr>
<tr class="separator:a5353c3c4076dd7b033eb522fed49a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5fbfc78c1648f91c907de6922568ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a5e5fbfc78c1648f91c907de6922568ad">Bootloader_socLoadSysFw</a> (void)</td></tr>
<tr class="memdesc:a5e5fbfc78c1648f91c907de6922568ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the System Controller Firmware (SYSFW) onto the Cortex M3 in AM64x SOC.  <a href="bootloader__soc_8h.html#a5e5fbfc78c1648f91c907de6922568ad">More...</a><br /></td></tr>
<tr class="separator:a5e5fbfc78c1648f91c907de6922568ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa206338d7f792f43b5b15a28deaf9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a18aa206338d7f792f43b5b15a28deaf9">Bootloader_socTranslateSectionAddr</a> (uint32_t cslCoreId, uint32_t <a class="el" href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>)</td></tr>
<tr class="memdesc:a18aa206338d7f792f43b5b15a28deaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a CPU address to the SOC address wherever applicable.  <a href="bootloader__soc_8h.html#a18aa206338d7f792f43b5b15a28deaf9">More...</a><br /></td></tr>
<tr class="separator:a18aa206338d7f792f43b5b15a28deaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1f2f44ae2bf70d8d4be057b89c3c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a99d1f2f44ae2bf70d8d4be057b89c3c2">Bootloader_socRprcToCslCoreId</a> (uint32_t rprcCoreId)</td></tr>
<tr class="memdesc:a99d1f2f44ae2bf70d8d4be057b89c3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the CSL core ID of a CPU from its RPRC core ID.  <a href="bootloader__soc_8h.html#a99d1f2f44ae2bf70d8d4be057b89c3c2">More...</a><br /></td></tr>
<tr class="separator:a99d1f2f44ae2bf70d8d4be057b89c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3678a87f6ba16457e7d8b184144446fb"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a3678a87f6ba16457e7d8b184144446fb">Bootloader_socGetSelfCpuList</a> (void)</td></tr>
<tr class="memdesc:a3678a87f6ba16457e7d8b184144446fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of self cpus in the SOC.  <a href="bootloader__soc_8h.html#a3678a87f6ba16457e7d8b184144446fb">More...</a><br /></td></tr>
<tr class="separator:a3678a87f6ba16457e7d8b184144446fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9cb411e08a1a4de9f16657f231ab13"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#acc9cb411e08a1a4de9f16657f231ab13">Bootloader_socGetCoreName</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:acc9cb411e08a1a4de9f16657f231ab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a core.  <a href="bootloader__soc_8h.html#acc9cb411e08a1a4de9f16657f231ab13">More...</a><br /></td></tr>
<tr class="separator:acc9cb411e08a1a4de9f16657f231ab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77850e55e56075d48be1418a37e2c5f2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a77850e55e56075d48be1418a37e2c5f2">Bootloader_socMemInitCpu</a> (uint32_t cpuId)</td></tr>
<tr class="memdesc:a77850e55e56075d48be1418a37e2c5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the core memories of a specific core.  <a href="bootloader__soc_8h.html#a77850e55e56075d48be1418a37e2c5f2">More...</a><br /></td></tr>
<tr class="separator:a77850e55e56075d48be1418a37e2c5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc93ac3743b226e98e13299aaddd5fa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#a3cc93ac3743b226e98e13299aaddd5fa">Bootloader_socSecHandover</a> (void)</td></tr>
<tr class="memdesc:a3cc93ac3743b226e98e13299aaddd5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to trigger the security handover from SYSFW.  <a href="bootloader__soc_8h.html#a3cc93ac3743b226e98e13299aaddd5fa">More...</a><br /></td></tr>
<tr class="separator:a3cc93ac3743b226e98e13299aaddd5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9dafbd41c6e7408cd909d1d9c53602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#ace9dafbd41c6e7408cd909d1d9c53602">Bootloader_socLoadSysFwLinux</a> (void)</td></tr>
<tr class="memdesc:ace9dafbd41c6e7408cd909d1d9c53602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the System Controller Firmware (SYSFW) onto the Cortex M3 in AM64x SOC (When SBL boots Linux)  <a href="bootloader__soc_8h.html#ace9dafbd41c6e7408cd909d1d9c53602">More...</a><br /></td></tr>
<tr class="separator:ace9dafbd41c6e7408cd909d1d9c53602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28fbefbc81af363a91fed4138db1860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bootloader__soc_8h.html#ac28fbefbc81af363a91fed4138db1860">Bootloader_socGetSBLMem</a> (uint32_t *start, uint32_t *end)</td></tr>
<tr class="memdesc:ac28fbefbc81af363a91fed4138db1860"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get the scratch memory limits used by SBL. If the application tries to load in this region, it might over write SBL.  <a href="bootloader__soc_8h.html#ac28fbefbc81af363a91fed4138db1860">More...</a><br /></td></tr>
<tr class="separator:ac28fbefbc81af363a91fed4138db1860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa275163c52f8cee1e1c96b323c38c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa275163c52f8cee1e1c96b323c38c163">&#9670;&nbsp;</a></span>Bootloader_socCpuRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request for a particular CPU in the AM64x SOC. </p>
<p>This API internally makes Sciclient calls to request control of the CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="afff97fe5ae5893a01813ea264f6af4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff97fe5ae5893a01813ea264f6af4ad">&#9670;&nbsp;</a></span>Bootloader_socCpuRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuRelease </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a particular CPU in the AM64x SOC. </p>
<p>This API internally makes Sciclient calls to release control of the CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="acca6ca3d5d169d20309abe96cbcbf3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca6ca3d5d169d20309abe96cbcbf3b3">&#9670;&nbsp;</a></span>Bootloader_socCpuSetClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuSetClock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuHz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the clock of a particular CPU in the AM64x SOC. </p>
<p>This API internally makes Sciclient calls to set CPU clock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core </td></tr>
    <tr><td class="paramname">cpuHz</td><td>[in] Desired clock frequency of the CPU in Hertz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="af250d95e4809165b42a2e00e65deb89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250d95e4809165b42a2e00e65deb89b">&#9670;&nbsp;</a></span>Bootloader_socCpuGetClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Bootloader_socCpuGetClock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the clock of a particular CPU in the AM64x SOC. </p>
<p>This API internally makes Sciclient calls to get the current clock frequency of CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current clock speed of the CPU </dd></dl>

</div>
</div>
<a id="a83f77ae23106afbd7173af93961aa8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f77ae23106afbd7173af93961aa8a3">&#9670;&nbsp;</a></span>Bootloader_socCpuGetClkDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Bootloader_socCpuGetClkDefault </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default clock of a particular CPU in the AM64x SOC. </p>
<p>This API queries and internal lookup table to fetch the default clock speed at which a particular CPU should run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Default clock speed of the CPU </dd></dl>

</div>
</div>
<a id="ab648751ddc094ceb2e0e05e33f179829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab648751ddc094ceb2e0e05e33f179829">&#9670;&nbsp;</a></span>Bootloader_socCpuPowerOnReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuPowerOnReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do power-on-reset of a particular CPU in the AM64x SOC. </p>
<p>This API is called only when booting a non-self CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="afc373fa0be1c31e324a84a6461805189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc373fa0be1c31e324a84a6461805189">&#9670;&nbsp;</a></span>Bootloader_socCpuResetRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuResetRelease </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>entryPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a particular CPU in the AM64x SOC from reset. </p>
<p>This API is called only when booting a non-self CPU. There is a different API <a class="el" href="bootloader__soc_8h.html#a3fdae485b83313a66ff7aca33c6b2e01">Bootloader_socCpuResetReleaseSelf</a> in the case of a self CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core </td></tr>
    <tr><td class="paramname">entryPoint</td><td>[in] The entryPoint of the CPU, from where it should start execution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="a3fdae485b83313a66ff7aca33c6b2e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdae485b83313a66ff7aca33c6b2e01">&#9670;&nbsp;</a></span>Bootloader_socCpuResetReleaseSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuResetReleaseSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release self CPU in the AM64x SOC from reset. </p>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="a5353c3c4076dd7b033eb522fed49a020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5353c3c4076dd7b033eb522fed49a020">&#9670;&nbsp;</a></span>Bootloader_socCpuSetEntryPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socCpuSetEntryPoint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>entryPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set entry point for self CPU in the AM64x SOC from reset. </p>
<p>This API need not be called when booting a non-self CPU. The entry point can be specified in the <a class="el" href="bootloader__soc_8h.html#afc373fa0be1c31e324a84a6461805189">Bootloader_socCpuResetRelease</a> function itself</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core </td></tr>
    <tr><td class="paramname">entryPoint</td><td>[in] The entryPoint of the CPU, from where it should start execution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="a5e5fbfc78c1648f91c907de6922568ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5fbfc78c1648f91c907de6922568ad">&#9670;&nbsp;</a></span>Bootloader_socLoadSysFw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_socLoadSysFw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the System Controller Firmware (SYSFW) onto the Cortex M3 in AM64x SOC. </p>
<p>The SYSFW is a special controller firmware loaded onto the Device Management and Security Controller (DMSC) core, i.e the Cortex M3. The SYSFW controls a multitude of things in the SOC, including Power, Clock, Resource Management and Security. So it is important to load the SYSFW onto the DMSC core before booting any application. Typically this API is called before anything else in the main loop of a Bootloader application </p>

</div>
</div>
<a id="a18aa206338d7f792f43b5b15a28deaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aa206338d7f792f43b5b15a28deaf9">&#9670;&nbsp;</a></span>Bootloader_socTranslateSectionAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Bootloader_socTranslateSectionAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cslCoreId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a CPU address to the SOC address wherever applicable. </p>
<p>This API need not be called when booting a non-self CPU. The entry point can be specified in the <a class="el" href="bootloader__soc_8h.html#afc373fa0be1c31e324a84a6461805189">Bootloader_socCpuResetRelease</a> function itself</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cslCoreId</td><td>[in] The CSL ID of the core </td></tr>
    <tr><td class="paramname">addr</td><td>[in] The CPU addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="a99d1f2f44ae2bf70d8d4be057b89c3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d1f2f44ae2bf70d8d4be057b89c3c2">&#9670;&nbsp;</a></span>Bootloader_socRprcToCslCoreId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Bootloader_socRprcToCslCoreId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rprcCoreId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the CSL core ID of a CPU from its RPRC core ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rprcCoreId</td><td>[in] The RPRC ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL core ID of a CPU </dd></dl>

</div>
</div>
<a id="a3678a87f6ba16457e7d8b184144446fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3678a87f6ba16457e7d8b184144446fb">&#9670;&nbsp;</a></span>Bootloader_socGetSelfCpuList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t* Bootloader_socGetSelfCpuList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of self cpus in the SOC. </p>
<dl class="section return"><dt>Returns</dt><dd>List of self cpus ending with an invalid core id </dd></dl>

</div>
</div>
<a id="acc9cb411e08a1a4de9f16657f231ab13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9cb411e08a1a4de9f16657f231ab13">&#9670;&nbsp;</a></span>Bootloader_socGetCoreName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Bootloader_socGetCoreName </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the CPU </dd></dl>

</div>
</div>
<a id="a77850e55e56075d48be1418a37e2c5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77850e55e56075d48be1418a37e2c5f2">&#9670;&nbsp;</a></span>Bootloader_socMemInitCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socMemInitCpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cpuId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the core memories of a specific core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuId</td><td>[in] The CSL ID of the core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="a3cc93ac3743b226e98e13299aaddd5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc93ac3743b226e98e13299aaddd5fa">&#9670;&nbsp;</a></span>Bootloader_socSecHandover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_socSecHandover </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to trigger the security handover from SYSFW. </p>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ace9dafbd41c6e7408cd909d1d9c53602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9dafbd41c6e7408cd909d1d9c53602">&#9670;&nbsp;</a></span>Bootloader_socLoadSysFwLinux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_socLoadSysFwLinux </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the System Controller Firmware (SYSFW) onto the Cortex M3 in AM64x SOC (When SBL boots Linux) </p>
<p>The SYSFW is a special controller firmware loaded onto the Device Management and Security Controller (DMSC) core, i.e the Cortex M3. The SYSFW controls a multitude of things in the SOC, including Power, Clock, Resource Management and Security. So it is important to load the SYSFW onto the DMSC core before booting any application. Typically this API is called before anything else in the main loop of a Bootloader application </p>

</div>
</div>
<a id="ac28fbefbc81af363a91fed4138db1860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28fbefbc81af363a91fed4138db1860">&#9670;&nbsp;</a></span>Bootloader_socGetSBLMem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_socGetSBLMem </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get the scratch memory limits used by SBL. If the application tries to load in this region, it might over write SBL. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_abc9ad036f51ba48b607241e5ebbccbe.html">drivers</a></li><li class="navelem"><a class="el" href="dir_33b7cf53d1db9c37c403b2d6e65b121c.html">bootloader</a></li><li class="navelem"><a class="el" href="dir_cbdf752cc52ca303dcc2c57f6a859de7.html">soc</a></li><li class="navelem"><a class="el" href="dir_f3c2ac9844c5c13786eda141a9844a38.html">am64x_am243x</a></li><li class="navelem"><a class="el" href="bootloader__soc_8h.html">bootloader_soc.h</a></li>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
