<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: APIs for BOOTLOADING CPUs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__BOOTLOADER__MODULE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">APIs for BOOTLOADING CPUs<div class="ingroups"><a class="el" href="group__DRV__MODULE.html">APIs for SOC Specific Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>See <a class="el" href="DRIVERS_BOOTLOADER_PAGE.html">BOOTLOADER</a> for more details. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__Params.html">Bootloader_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters passed during <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f" title="Open bootloader driver.">Bootloader_open()</a>  <a href="structBootloader__Params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__Fxns.html">Bootloader_Fxns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation callbacks.  <a href="structBootloader__Fxns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__Config.html">Bootloader_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootloader driver configuration, these are filled by SysCfg based on the boot media selected.  <a href="structBootloader__Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information related to a particular CPU, required for RPRC loading.  <a href="structBootloader__CpuInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing information related all CPUs, this will be filled by Bootloader_parseMultiCoreAppImage.  <a href="structBootloader__BootImageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga39a9f1cb3fec1b556e44946d31f67c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga39a9f1cb3fec1b556e44946d31f67c60">Bootloader_Params_init</a> (<a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *params)</td></tr>
<tr class="memdesc:ga39a9f1cb3fec1b556e44946d31f67c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Bootloader params.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga39a9f1cb3fec1b556e44946d31f67c60">More...</a><br /></td></tr>
<tr class="separator:ga39a9f1cb3fec1b556e44946d31f67c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf464ec57e0961d6270fc257fab9396a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gaf464ec57e0961d6270fc257fab9396a5">Bootloader_BootImageInfo_init</a> (<a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *bootImageInfo)</td></tr>
<tr class="memdesc:gaf464ec57e0961d6270fc257fab9396a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize BootImage info.  <a href="group__DRV__BOOTLOADER__MODULE.html#gaf464ec57e0961d6270fc257fab9396a5">More...</a><br /></td></tr>
<tr class="separator:gaf464ec57e0961d6270fc257fab9396a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7244317647cc0eabeb119635e46c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8e7244317647cc0eabeb119635e46c49">Bootloader_CpuInfo_init</a> (<a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:ga8e7244317647cc0eabeb119635e46c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CPU info.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga8e7244317647cc0eabeb119635e46c49">More...</a><br /></td></tr>
<tr class="separator:ga8e7244317647cc0eabeb119635e46c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9456896dc1df25051d0ad6467767a39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> (uint32_t instanceNum, <a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *openParams)</td></tr>
<tr class="memdesc:ga9456896dc1df25051d0ad6467767a39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open bootloader driver.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">More...</a><br /></td></tr>
<tr class="separator:ga9456896dc1df25051d0ad6467767a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021ceadeefd7c709ba42b9c23775ec92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga021ceadeefd7c709ba42b9c23775ec92">Bootloader_close</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle)</td></tr>
<tr class="memdesc:ga021ceadeefd7c709ba42b9c23775ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close bootloader driver.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga021ceadeefd7c709ba42b9c23775ec92">More...</a><br /></td></tr>
<tr class="separator:ga021ceadeefd7c709ba42b9c23775ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c40b9b20eeb7f5c8df26b2dd009752"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga17c40b9b20eeb7f5c8df26b2dd009752">Bootloader_loadCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:ga17c40b9b20eeb7f5c8df26b2dd009752"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to load a non-self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga17c40b9b20eeb7f5c8df26b2dd009752">More...</a><br /></td></tr>
<tr class="separator:ga17c40b9b20eeb7f5c8df26b2dd009752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ac1314f99b816aa05b86ec40912639"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga91ac1314f99b816aa05b86ec40912639">Bootloader_loadSelfCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:ga91ac1314f99b816aa05b86ec40912639"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to load self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga91ac1314f99b816aa05b86ec40912639">More...</a><br /></td></tr>
<tr class="separator:ga91ac1314f99b816aa05b86ec40912639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e8b0c243d3f57230d56bd76e265bda"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gab7e8b0c243d3f57230d56bd76e265bda">Bootloader_runCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:gab7e8b0c243d3f57230d56bd76e265bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to run a non-self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#gab7e8b0c243d3f57230d56bd76e265bda">More...</a><br /></td></tr>
<tr class="separator:gab7e8b0c243d3f57230d56bd76e265bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a55e1117a1504daa49d6df9679b8e6d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga5a55e1117a1504daa49d6df9679b8e6d">Bootloader_runSelfCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *bootImageInfo)</td></tr>
<tr class="memdesc:ga5a55e1117a1504daa49d6df9679b8e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to boot self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga5a55e1117a1504daa49d6df9679b8e6d">More...</a><br /></td></tr>
<tr class="separator:ga5a55e1117a1504daa49d6df9679b8e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8557a235032dc8cd0c6c95e2b75589d6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8557a235032dc8cd0c6c95e2b75589d6">Bootloader_bootCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:ga8557a235032dc8cd0c6c95e2b75589d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to boot a non-self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga8557a235032dc8cd0c6c95e2b75589d6">More...</a><br /></td></tr>
<tr class="separator:ga8557a235032dc8cd0c6c95e2b75589d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9332cf8c76bfe261725d756d7c2e6d2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gab9332cf8c76bfe261725d756d7c2e6d2">Bootloader_bootSelfCpu</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *bootImageInfo)</td></tr>
<tr class="memdesc:gab9332cf8c76bfe261725d756d7c2e6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to boot self CPU.  <a href="group__DRV__BOOTLOADER__MODULE.html#gab9332cf8c76bfe261725d756d7c2e6d2">More...</a><br /></td></tr>
<tr class="separator:gab9332cf8c76bfe261725d756d7c2e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ec27a94c8eb03ab07cfac533223153"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *bootImageInfo)</td></tr>
<tr class="memdesc:gad6ec27a94c8eb03ab07cfac533223153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse Multicore Appimage.  <a href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">More...</a><br /></td></tr>
<tr class="separator:gad6ec27a94c8eb03ab07cfac533223153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5635214cf9e6f2fea76ab6f601366c4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad5635214cf9e6f2fea76ab6f601366c4">Bootloader_rprcImageParseEntryPoint</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:gad5635214cf9e6f2fea76ab6f601366c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse entrypoint from RPRC.  <a href="group__DRV__BOOTLOADER__MODULE.html#gad5635214cf9e6f2fea76ab6f601366c4">More...</a><br /></td></tr>
<tr class="separator:gad5635214cf9e6f2fea76ab6f601366c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bc7f850024d2a5c64875fe0c1fe518"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga08bc7f850024d2a5c64875fe0c1fe518">Bootloader_rprcImageLoad</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *cpuInfo)</td></tr>
<tr class="memdesc:ga08bc7f850024d2a5c64875fe0c1fe518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load application binaries into SOC memory.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga08bc7f850024d2a5c64875fe0c1fe518">More...</a><br /></td></tr>
<tr class="separator:ga08bc7f850024d2a5c64875fe0c1fe518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982f4d8f17d9dbfc587aa672732ec663"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga982f4d8f17d9dbfc587aa672732ec663">Bootloader_parseAndLoadLinuxAppImage</a> (<a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> handle, <a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *bootImageInfo)</td></tr>
<tr class="memdesc:ga982f4d8f17d9dbfc587aa672732ec663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and load linux Appimage, containing linux binaries(ATF, OPTEE, SPL)  <a href="group__DRV__BOOTLOADER__MODULE.html#ga982f4d8f17d9dbfc587aa672732ec663">More...</a><br /></td></tr>
<tr class="separator:ga982f4d8f17d9dbfc587aa672732ec663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1444b0d35694d4bbd4076f60b75374fa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga1444b0d35694d4bbd4076f60b75374fa">Bootloader_runSelfCpuWithLinux</a> ()</td></tr>
<tr class="memdesc:ga1444b0d35694d4bbd4076f60b75374fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to boot self CPU with Linux.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga1444b0d35694d4bbd4076f60b75374fa">More...</a><br /></td></tr>
<tr class="separator:ga1444b0d35694d4bbd4076f60b75374fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8c2fc1e55aeabdc0aeb19b979fa8d662"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a></td></tr>
<tr class="memdesc:ga8c2fc1e55aeabdc0aeb19b979fa8d662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to the Bootloader driver returned by <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f" title="Open bootloader driver.">Bootloader_open()</a>  <a href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">More...</a><br /></td></tr>
<tr class="separator:ga8c2fc1e55aeabdc0aeb19b979fa8d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0eb47377a4166499a4f17eae09f2c070"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga0eb47377a4166499a4f17eae09f2c070">BOOTLOADER_INVALID_ID</a>&#160;&#160;&#160;(0xDEADBABE)</td></tr>
<tr class="memdesc:ga0eb47377a4166499a4f17eae09f2c070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid ID magic number to be used for initializations.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga0eb47377a4166499a4f17eae09f2c070">More...</a><br /></td></tr>
<tr class="separator:ga0eb47377a4166499a4f17eae09f2c070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bootloader driver implementation callbacks</h2></td></tr>
<tr class="memitem:ga78ee19c2e608954d09585ce9668a4551"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga78ee19c2e608954d09585ce9668a4551">Bootloader_imgOpenFxn</a>) (void *args, <a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *params)</td></tr>
<tr class="memdesc:ga78ee19c2e608954d09585ce9668a4551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation to open a specific bootloader driver - Memory, OSPI, UART, MMCSD etc.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga78ee19c2e608954d09585ce9668a4551">More...</a><br /></td></tr>
<tr class="separator:ga78ee19c2e608954d09585ce9668a4551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c39e64013ab688283356f42ecab831"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga70c39e64013ab688283356f42ecab831">Bootloader_imgReadFxn</a>) (void *dstAddr, uint32_t length, void *args)</td></tr>
<tr class="memdesc:ga70c39e64013ab688283356f42ecab831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation to read from boot media using a specific bootloader driver - Memory, OSPI, UART, MMCSD etc.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga70c39e64013ab688283356f42ecab831">More...</a><br /></td></tr>
<tr class="separator:ga70c39e64013ab688283356f42ecab831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b855502f5d75c54798beb1f40ef908d"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9b855502f5d75c54798beb1f40ef908d">Bootloader_imgOffsetFxn</a>) (void *args)</td></tr>
<tr class="memdesc:ga9b855502f5d75c54798beb1f40ef908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation to get the current offset in the boot media.  <a href="group__DRV__BOOTLOADER__MODULE.html#ga9b855502f5d75c54798beb1f40ef908d">More...</a><br /></td></tr>
<tr class="separator:ga9b855502f5d75c54798beb1f40ef908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0651cd748cdc21b93bbee5582f987e7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gab0651cd748cdc21b93bbee5582f987e7">Bootloader_imgSeekFxn</a>) (uint32_t location, void *args)</td></tr>
<tr class="memdesc:gab0651cd748cdc21b93bbee5582f987e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation to read from boot media using a specific bootloader driver - Memory, OSPI, UART, MMCSD etc.  <a href="group__DRV__BOOTLOADER__MODULE.html#gab0651cd748cdc21b93bbee5582f987e7">More...</a><br /></td></tr>
<tr class="separator:gab0651cd748cdc21b93bbee5582f987e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a1d101761cf46db63e3efffe72163d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gae3a1d101761cf46db63e3efffe72163d">Bootloader_imgCloseFxn</a>) (void *handle, void *args)</td></tr>
<tr class="memdesc:gae3a1d101761cf46db63e3efffe72163d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver implementation to close a specific bootloader driver - Memory, OSPI, UART, MMCSD etc.  <a href="group__DRV__BOOTLOADER__MODULE.html#gae3a1d101761cf46db63e3efffe72163d">More...</a><br /></td></tr>
<tr class="separator:gae3a1d101761cf46db63e3efffe72163d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0eb47377a4166499a4f17eae09f2c070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb47377a4166499a4f17eae09f2c070">&#9670;&nbsp;</a></span>BOOTLOADER_INVALID_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOTLOADER_INVALID_ID&#160;&#160;&#160;(0xDEADBABE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid ID magic number to be used for initializations. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8c2fc1e55aeabdc0aeb19b979fa8d662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2fc1e55aeabdc0aeb19b979fa8d662">&#9670;&nbsp;</a></span>Bootloader_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to the Bootloader driver returned by <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f" title="Open bootloader driver.">Bootloader_open()</a> </p>

</div>
</div>
<a id="ga78ee19c2e608954d09585ce9668a4551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ee19c2e608954d09585ce9668a4551">&#9670;&nbsp;</a></span>Bootloader_imgOpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* Bootloader_imgOpenFxn) (void *args, <a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver implementation to open a specific bootloader driver - Memory, OSPI, UART, MMCSD etc. </p>
<p>Typically this callback is hidden from the end application and is implemented when a new boot media needs to be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>[in] Boot media specific arguments, obtained from the config </td></tr>
    <tr><td class="paramname">params</td><td>[in] User controllable params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga70c39e64013ab688283356f42ecab831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c39e64013ab688283356f42ecab831">&#9670;&nbsp;</a></span>Bootloader_imgReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* Bootloader_imgReadFxn) (void *dstAddr, uint32_t length, void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver implementation to read from boot media using a specific bootloader driver - Memory, OSPI, UART, MMCSD etc. </p>
<p>Typically this callback is hidden from the end application and is implemented when a new boot media needs to be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstAddr</td><td>[in] Destination address to which the data is to be read into </td></tr>
    <tr><td class="paramname">length</td><td>[in] Length in bytes of the data to be read </td></tr>
    <tr><td class="paramname">args</td><td>[in] Boot media specific arguments, obtained from the config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga9b855502f5d75c54798beb1f40ef908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b855502f5d75c54798beb1f40ef908d">&#9670;&nbsp;</a></span>Bootloader_imgOffsetFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* Bootloader_imgOffsetFxn) (void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver implementation to get the current offset in the boot media. </p>
<p>Typically this callback is hidden from the end application and is implemented when a new boot media needs to be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>[in] Boot media specific arguments, obtained from the config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current Offset </dd></dl>

</div>
</div>
<a id="gab0651cd748cdc21b93bbee5582f987e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0651cd748cdc21b93bbee5582f987e7">&#9670;&nbsp;</a></span>Bootloader_imgSeekFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Bootloader_imgSeekFxn) (uint32_t location, void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver implementation to read from boot media using a specific bootloader driver - Memory, OSPI, UART, MMCSD etc. </p>
<p>Typically this callback is hidden from the end application and is implemented when a new boot media needs to be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstAddr</td><td>[in] Destination address to which the data is to be read into </td></tr>
    <tr><td class="paramname">length</td><td>[in] Length in bytes of the data to be read </td></tr>
    <tr><td class="paramname">args</td><td>[in] Boot media specific arguments, obtained from the config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="gae3a1d101761cf46db63e3efffe72163d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3a1d101761cf46db63e3efffe72163d">&#9670;&nbsp;</a></span>Bootloader_imgCloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Bootloader_imgCloseFxn) (void *handle, void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver implementation to close a specific bootloader driver - Memory, OSPI, UART, MMCSD etc. </p>
<p>Typically this callback is hidden from the end application and is implemented when a new boot media needs to be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Handle returned from Bootloader_imgOpen </td></tr>
    <tr><td class="paramname">args</td><td>[in] Boot media specific arguments, obtained from the config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga39a9f1cb3fec1b556e44946d31f67c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a9f1cb3fec1b556e44946d31f67c60">&#9670;&nbsp;</a></span>Bootloader_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Bootloader params. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[out] Pointer to a <a class="el" href="structBootloader__Params.html">Bootloader_Params</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf464ec57e0961d6270fc257fab9396a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf464ec57e0961d6270fc257fab9396a5">&#9670;&nbsp;</a></span>Bootloader_BootImageInfo_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_BootImageInfo_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *&#160;</td>
          <td class="paramname"><em>bootImageInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize BootImage info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bootImageInfo</td><td>[out] Pointer to a <a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e7244317647cc0eabeb119635e46c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7244317647cc0eabeb119635e46c49">&#9670;&nbsp;</a></span>Bootloader_CpuInfo_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_CpuInfo_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CPU info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuInfo</td><td>[out] Pointer to a <a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9456896dc1df25051d0ad6467767a39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9456896dc1df25051d0ad6467767a39f">&#9670;&nbsp;</a></span>Bootloader_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a> Bootloader_open </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instanceNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__Params.html">Bootloader_Params</a> *&#160;</td>
          <td class="paramname"><em>openParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open bootloader driver. </p>
<p>Make sure the SOC periheral driver is open'ed before calling this API. Drivers_open function generated by SysCfg opens the underlying SOC peripheral driver, e.g OSPI.</p>
<p>Global variables <code><a class="el" href="structBootloader__Config.html" title="Bootloader driver configuration, these are filled by SysCfg based on the boot media selected.">Bootloader_Config</a> gBootloaderConfig[]</code> and <code>uint32_t gBootloaderConfigNum</code> is instantiated by SysCfg to describe the boot media and other configuration based on user selection in SysCfg.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instanceNum</td><td>[in] Index within <code><a class="el" href="structBootloader__Config.html" title="Bootloader driver configuration, these are filled by SysCfg based on the boot media selected.">Bootloader_Config</a> gBootloaderConfig[]</code> denoting the bootloader driver to open </td></tr>
    <tr><td class="paramname">openParams</td><td>[in] Open parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to bootloader driver which should be used in subsequent API call </dd>
<dd>
NULL in case of failure </dd></dl>

</div>
</div>
<a id="ga021ceadeefd7c709ba42b9c23775ec92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga021ceadeefd7c709ba42b9c23775ec92">&#9670;&nbsp;</a></span>Bootloader_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bootloader_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close bootloader driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17c40b9b20eeb7f5c8df26b2dd009752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17c40b9b20eeb7f5c8df26b2dd009752">&#9670;&nbsp;</a></span>Bootloader_loadCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_loadCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to load a non-self CPU. </p>
<p>This API will load RPRC images a non-self CPU, i.e a CPU on which the bootloader application is not running. This API is not applicable for cores from self cluster. They will be loaded by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga91ac1314f99b816aa05b86ec40912639">Bootloader_loadSelfCpu</a> API.</p>
<p>NOTE: No checks are done to confirm non-self CPU ID is passed, user need to make sure non-self CPU ID is passed, else the load could fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">cpuInfo</td><td>[in] Data structure containing information regarding the CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga91ac1314f99b816aa05b86ec40912639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ac1314f99b816aa05b86ec40912639">&#9670;&nbsp;</a></span>Bootloader_loadSelfCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_loadSelfCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to load self CPU. </p>
<p>This API will load RPRC images on self CPU, i.e a CPU on which the bootloader application is running</p>
<p>NOTE: No checks are done to confirm self CPU ID is passed, user need to make sure self CPU ID is passed, else the load could fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">cpuInfo</td><td>[in] Data structure containing information regarding the CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="gab7e8b0c243d3f57230d56bd76e265bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e8b0c243d3f57230d56bd76e265bda">&#9670;&nbsp;</a></span>Bootloader_runCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_runCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to run a non-self CPU. </p>
<p>This API will run a non-self CPU, i.e a CPU on which the bootloader application is not running. This API is not applicable for cores from self cluster. They will be run by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga5a55e1117a1504daa49d6df9679b8e6d">Bootloader_runSelfCpu</a> API. It is expected that this API be called after <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga17c40b9b20eeb7f5c8df26b2dd009752">Bootloader_loadCpu</a> API</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">cpuInfo</td><td>[in] Data structure containing information regarding the CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga5a55e1117a1504daa49d6df9679b8e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a55e1117a1504daa49d6df9679b8e6d">&#9670;&nbsp;</a></span>Bootloader_runSelfCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_runSelfCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *&#160;</td>
          <td class="paramname"><em>bootImageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to boot self CPU. </p>
<p>This API will boot self CPU, i.e a CPU on which the bootloader application is running. It is expected that this API be called after <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga91ac1314f99b816aa05b86ec40912639">Bootloader_loadSelfCpu</a> API</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">bootImageInfo</td><td>[in] Data structure of type <a class="el" href="structBootloader__BootImageInfo.html" title="Data structure containing information related all CPUs, this will be filled by Bootloader_parseMultiC...">Bootloader_BootImageInfo</a> containing information regarding self CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga8557a235032dc8cd0c6c95e2b75589d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8557a235032dc8cd0c6c95e2b75589d6">&#9670;&nbsp;</a></span>Bootloader_bootCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_bootCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to boot a non-self CPU. </p>
<p>This API will boot a non-self CPU, i.e a CPU on which the bootloader application is not running. Now if the self CPU is a dual core CPU, like a Cortex R5, this API is not applicable for the second core of the self CPU. That will be booted by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gab9332cf8c76bfe261725d756d7c2e6d2">Bootloader_bootSelfCpu</a> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">cpuInfo</td><td>[in] Data structure containing information regarding the CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="gab9332cf8c76bfe261725d756d7c2e6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9332cf8c76bfe261725d756d7c2e6d2">&#9670;&nbsp;</a></span>Bootloader_bootSelfCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_bootSelfCpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *&#160;</td>
          <td class="paramname"><em>bootImageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to boot self CPU. </p>
<p>This API will boot self CPU, i.e a CPU on which the bootloader application is running</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">bootImageInfo</td><td>[in] Data structure of type <a class="el" href="structBootloader__BootImageInfo.html" title="Data structure containing information related all CPUs, this will be filled by Bootloader_parseMultiC...">Bootloader_BootImageInfo</a> containing information regarding self CPU. This should have been filled by the <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#gad6ec27a94c8eb03ab07cfac533223153">Bootloader_parseMultiCoreAppImage</a> API</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="gad6ec27a94c8eb03ab07cfac533223153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6ec27a94c8eb03ab07cfac533223153">&#9670;&nbsp;</a></span>Bootloader_parseMultiCoreAppImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_parseMultiCoreAppImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *&#160;</td>
          <td class="paramname"><em>bootImageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse Multicore Appimage. </p>
<p>When the booting is done through some boot media, unlike loading via CCS, the application binaries for each core applicable are converted into a file format '.rprc' and combined together into a multicore appimage binary. The bootloader needs to read this appimage, and load the binaries correctly into memories. This API helps in parsing the multicore appimage and filling the metadata in the bootImageInfo structure passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">bootImageInfo</td><td>[in] Data structure of type <a class="el" href="structBootloader__BootImageInfo.html" title="Data structure containing information related all CPUs, this will be filled by Bootloader_parseMultiC...">Bootloader_BootImageInfo</a> which will be filled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="gad5635214cf9e6f2fea76ab6f601366c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5635214cf9e6f2fea76ab6f601366c4">&#9670;&nbsp;</a></span>Bootloader_rprcImageParseEntryPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_rprcImageParseEntryPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse entrypoint from RPRC. </p>
<p>This API reads the RPRC image to parse the entry points of a particular CPU </p>

</div>
</div>
<a id="ga08bc7f850024d2a5c64875fe0c1fe518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bc7f850024d2a5c64875fe0c1fe518">&#9670;&nbsp;</a></span>Bootloader_rprcImageLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_rprcImageLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__CpuInfo.html">Bootloader_CpuInfo</a> *&#160;</td>
          <td class="paramname"><em>cpuInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load application binaries into SOC memory. </p>
<p>This API loads the application binaries for each core applicable is loaded from the boot media to the SOC memory </p>

</div>
</div>
<a id="ga982f4d8f17d9dbfc587aa672732ec663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982f4d8f17d9dbfc587aa672732ec663">&#9670;&nbsp;</a></span>Bootloader_parseAndLoadLinuxAppImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_parseAndLoadLinuxAppImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga8c2fc1e55aeabdc0aeb19b979fa8d662">Bootloader_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBootloader__BootImageInfo.html">Bootloader_BootImageInfo</a> *&#160;</td>
          <td class="paramname"><em>bootImageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and load linux Appimage, containing linux binaries(ATF, OPTEE, SPL) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[in] Bootloader driver handle from <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga9456896dc1df25051d0ad6467767a39f">Bootloader_open</a> </td></tr>
    <tr><td class="paramname">bootImageInfo</td><td>[in] Data structure of type <a class="el" href="structBootloader__BootImageInfo.html" title="Data structure containing information related all CPUs, this will be filled by Bootloader_parseMultiC...">Bootloader_BootImageInfo</a> which will be filled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
<a id="ga1444b0d35694d4bbd4076f60b75374fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1444b0d35694d4bbd4076f60b75374fa">&#9670;&nbsp;</a></span>Bootloader_runSelfCpuWithLinux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Bootloader_runSelfCpuWithLinux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to boot self CPU with Linux. </p>
<p>This API will boot self CPU, i.e a CPU on which the bootloader application is running. It is expected that this API be called after <a class="el" href="group__DRV__BOOTLOADER__MODULE.html#ga91ac1314f99b816aa05b86ec40912639">Bootloader_loadSelfCpu</a> API. This API does not perform a security handoff</p>
<dl class="section return"><dt>Returns</dt><dd>SystemP_SUCCESS on success, else failure </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
