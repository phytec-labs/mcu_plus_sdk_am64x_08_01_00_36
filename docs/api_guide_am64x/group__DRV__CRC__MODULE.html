<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: APIs for CRC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__CRC__MODULE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">APIs for CRC<div class="ingroups"><a class="el" href="group__DRV__MODULE.html">APIs for SOC Specific Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>This module contains APIs to program and use the CRC module. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:crc_2v0_2crc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crc_2v0_2crc_8h.html">crc/v0/crc.h</a></td></tr>
<tr class="memdesc:crc_2v0_2crc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC Driver API/interface file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrcSignature__t.html">crcSignature_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for accessing CRC register data which are 64 bit wide.  <a href="structcrcSignature__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrcSignatureRegAddr__t.html">crcSignatureRegAddr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for accessing CRC registers address which are 64 bit wide.  <a href="structcrcSignatureRegAddr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCrc__ChannelStaticRegs.html">Crc_ChannelStaticRegs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC channel static registers list.  <a href="structCrc__ChannelStaticRegs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCrc__StaticRegs.html">Crc_StaticRegs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC static registers list.  <a href="structCrc__StaticRegs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1d528be4ec219989ea1c82a2a53080f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaf1d528be4ec219989ea1c82a2a53080f">CRCInitialize</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcWatchdogPreload, uint32_t crcBlockPreload)</td></tr>
<tr class="memdesc:gaf1d528be4ec219989ea1c82a2a53080f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CRC channel and will configure watchdog and block preload value for given channel.  <a href="group__DRV__CRC__MODULE.html#gaf1d528be4ec219989ea1c82a2a53080f">More...</a><br /></td></tr>
<tr class="separator:gaf1d528be4ec219989ea1c82a2a53080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2883454c481524baf9ba8594a6d6d57"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaf2883454c481524baf9ba8594a6d6d57">CRCVerifyInitialize</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcWatchdogPreload, uint32_t crcBlockPreload)</td></tr>
<tr class="memdesc:gaf2883454c481524baf9ba8594a6d6d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the CRC watchdog and block preload value initialized for given channel.  <a href="group__DRV__CRC__MODULE.html#gaf2883454c481524baf9ba8594a6d6d57">More...</a><br /></td></tr>
<tr class="separator:gaf2883454c481524baf9ba8594a6d6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab100922d0ce9e269d1fb0ac524ec71cb">CRCConfigure</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcPatternCount, uint32_t crcSectorCount, <a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a> crcMode)</td></tr>
<tr class="memdesc:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will configure CRC mode, pattern and sector count for given channel.  <a href="group__DRV__CRC__MODULE.html#gab100922d0ce9e269d1fb0ac524ec71cb">More...</a><br /></td></tr>
<tr class="separator:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559bd16f4436d4bf626a479fa70f5540"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga559bd16f4436d4bf626a479fa70f5540">CRCVerifyConfigure</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcPatternCount, uint32_t crcSectorCount, <a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a> crcMode)</td></tr>
<tr class="memdesc:ga559bd16f4436d4bf626a479fa70f5540"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will verify the configure of CRC mode, pattern and sector count for given channel.  <a href="group__DRV__CRC__MODULE.html#ga559bd16f4436d4bf626a479fa70f5540">More...</a><br /></td></tr>
<tr class="separator:ga559bd16f4436d4bf626a479fa70f5540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986eb01b813b10a74bc20ee60a748eef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga986eb01b813b10a74bc20ee60a748eef">CRCChannelReset</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel)</td></tr>
<tr class="memdesc:ga986eb01b813b10a74bc20ee60a748eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to reset the CRC channel.  <a href="group__DRV__CRC__MODULE.html#ga986eb01b813b10a74bc20ee60a748eef">More...</a><br /></td></tr>
<tr class="separator:ga986eb01b813b10a74bc20ee60a748eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308100fb0c56aabeeb2dcad350173233"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga308100fb0c56aabeeb2dcad350173233">CRCGetPSASigRegAddr</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="structcrcSignatureRegAddr__t.html">crcSignatureRegAddr_t</a> *pCRCRegAddr)</td></tr>
<tr class="memdesc:ga308100fb0c56aabeeb2dcad350173233"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the PSA register address for given Channel.  <a href="group__DRV__CRC__MODULE.html#ga308100fb0c56aabeeb2dcad350173233">More...</a><br /></td></tr>
<tr class="separator:ga308100fb0c56aabeeb2dcad350173233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gae1ad20b7cb7075cad634a01e0f084dcb">CRCGetPSASig</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *pCRCPSASign)</td></tr>
<tr class="memdesc:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the PSA register value for given Channel.  <a href="group__DRV__CRC__MODULE.html#gae1ad20b7cb7075cad634a01e0f084dcb">More...</a><br /></td></tr>
<tr class="separator:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gad49330fea3c0ac807ae8e9e70f00a5e4">CRCSetPSASeedSig</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, const <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *pCRCPSASeedSign)</td></tr>
<tr class="memdesc:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set the PSA seed value without compression for given Channel.  <a href="group__DRV__CRC__MODULE.html#gad49330fea3c0ac807ae8e9e70f00a5e4">More...</a><br /></td></tr>
<tr class="separator:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga1eab9ba6d3098f09fb5c23445005a54b">CRCGetPSASectorSig</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *pCRCSectorSign)</td></tr>
<tr class="memdesc:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get sector signature Value/ CRC value for given channel.  <a href="group__DRV__CRC__MODULE.html#ga1eab9ba6d3098f09fb5c23445005a54b">More...</a><br /></td></tr>
<tr class="separator:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6123f3d71a683cc23a18264376007e63"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga6123f3d71a683cc23a18264376007e63">CRCGetHighestPriorityIntrStatus</a> (uint32_t baseAddr, uint32_t *pIntVecAddr)</td></tr>
<tr class="memdesc:ga6123f3d71a683cc23a18264376007e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the pending interrupt with highest priority.  <a href="group__DRV__CRC__MODULE.html#ga6123f3d71a683cc23a18264376007e63">More...</a><br /></td></tr>
<tr class="separator:ga6123f3d71a683cc23a18264376007e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaab02b753542d9f0ef26f9cca56e91ecf">CRCGetIntrStatus</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pIntrStatus)</td></tr>
<tr class="memdesc:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the pending interrupts for given Channel.  <a href="group__DRV__CRC__MODULE.html#gaab02b753542d9f0ef26f9cca56e91ecf">More...</a><br /></td></tr>
<tr class="separator:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2403b0f0b751df526cd4898569bf436d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga2403b0f0b751df526cd4898569bf436d">CRCEnableIntr</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga2403b0f0b751df526cd4898569bf436d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable interrupts for given Channel.  <a href="group__DRV__CRC__MODULE.html#ga2403b0f0b751df526cd4898569bf436d">More...</a><br /></td></tr>
<tr class="separator:ga2403b0f0b751df526cd4898569bf436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356d6deabd7fbe11005ad0e903975045"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga356d6deabd7fbe11005ad0e903975045">CRCDisableIntr</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga356d6deabd7fbe11005ad0e903975045"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to disable interrupts for given Channel.  <a href="group__DRV__CRC__MODULE.html#ga356d6deabd7fbe11005ad0e903975045">More...</a><br /></td></tr>
<tr class="separator:ga356d6deabd7fbe11005ad0e903975045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71509ef795b47e2400a72c47109f9b6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab71509ef795b47e2400a72c47109f9b6">CRCClearIntr</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:gab71509ef795b47e2400a72c47109f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to clear interrupts for given Channel.  <a href="group__DRV__CRC__MODULE.html#gab71509ef795b47e2400a72c47109f9b6">More...</a><br /></td></tr>
<tr class="separator:gab71509ef795b47e2400a72c47109f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79190e984729641dd78a7f123a8628e1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga79190e984729641dd78a7f123a8628e1">CRCPowerDownCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag)</td></tr>
<tr class="memdesc:ga79190e984729641dd78a7f123a8628e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control the power down of the CRC module.  <a href="group__DRV__CRC__MODULE.html#ga79190e984729641dd78a7f123a8628e1">More...</a><br /></td></tr>
<tr class="separator:ga79190e984729641dd78a7f123a8628e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155f2eb0b82fa4811ac4f625607db982"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga155f2eb0b82fa4811ac4f625607db982">CRCIsBusy</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pBusyFlag)</td></tr>
<tr class="memdesc:ga155f2eb0b82fa4811ac4f625607db982"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to check if CRC is busy for given Channel.  <a href="group__DRV__CRC__MODULE.html#ga155f2eb0b82fa4811ac4f625607db982">More...</a><br /></td></tr>
<tr class="separator:ga155f2eb0b82fa4811ac4f625607db982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bee1b027384ffecae6828a1b6512f4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaf7bee1b027384ffecae6828a1b6512f4">CRCGetCurSecNum</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pCurSecNum)</td></tr>
<tr class="memdesc:gaf7bee1b027384ffecae6828a1b6512f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the current sector number of which the signature verification fails in AUTO mode for given channel.  <a href="group__DRV__CRC__MODULE.html#gaf7bee1b027384ffecae6828a1b6512f4">More...</a><br /></td></tr>
<tr class="separator:gaf7bee1b027384ffecae6828a1b6512f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52320890e39ad27ff3ab9561402be321"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga52320890e39ad27ff3ab9561402be321">CRCGetCurPSASig</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *pCurPSASig)</td></tr>
<tr class="memdesc:ga52320890e39ad27ff3ab9561402be321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get current known good signature value/ CRC value for given channel.  <a href="group__DRV__CRC__MODULE.html#ga52320890e39ad27ff3ab9561402be321">More...</a><br /></td></tr>
<tr class="separator:ga52320890e39ad27ff3ab9561402be321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d1b2540776a00821c0bfce73234e1f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga56d1b2540776a00821c0bfce73234e1f">CRCGetRawData</a> (uint32_t baseAddr, <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *pRawData)</td></tr>
<tr class="memdesc:ga56d1b2540776a00821c0bfce73234e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the uncompressed raw data value for given channel.  <a href="group__DRV__CRC__MODULE.html#ga56d1b2540776a00821c0bfce73234e1f">More...</a><br /></td></tr>
<tr class="separator:ga56d1b2540776a00821c0bfce73234e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gac3d5dc88321f5e5561aff2ddf7e7a047">CRCDataBusTracingCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag, <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> dataBusMask, <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> busEnableMask)</td></tr>
<tr class="memdesc:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control the CRC data bus tracing.  <a href="group__DRV__CRC__MODULE.html#gac3d5dc88321f5e5561aff2ddf7e7a047">More...</a><br /></td></tr>
<tr class="separator:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5967fdbd2766ecca927d8fccbb51b01"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab5967fdbd2766ecca927d8fccbb51b01">CRCVerifyBusTracingCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag, <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> dataBusMask, <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> busEnableMask)</td></tr>
<tr class="memdesc:gab5967fdbd2766ecca927d8fccbb51b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to verify the control the CRC data bus tracing.  <a href="group__DRV__CRC__MODULE.html#gab5967fdbd2766ecca927d8fccbb51b01">More...</a><br /></td></tr>
<tr class="separator:gab5967fdbd2766ecca927d8fccbb51b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd1c4a11fa93f281a505a527601d8e2d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gafd1c4a11fa93f281a505a527601d8e2d">CRCReadStaticRegs</a> (uint32_t baseAddr, <a class="el" href="structCrc__StaticRegs.html">Crc_StaticRegs</a> *pStaticRegs)</td></tr>
<tr class="memdesc:gafd1c4a11fa93f281a505a527601d8e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read static registers of CRC module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values.  <a href="group__DRV__CRC__MODULE.html#gafd1c4a11fa93f281a505a527601d8e2d">More...</a><br /></td></tr>
<tr class="separator:gafd1c4a11fa93f281a505a527601d8e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6f0880155b752d7ecca5b70d8ef01481"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga6f0880155b752d7ecca5b70d8ef01481">CRC_CHANNEL_IRQSTATUS_RAW_MAIN_ALL</a></td></tr>
<tr class="memdesc:ga6f0880155b752d7ecca5b70d8ef01481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro defines mask for all the interrupts for a channel.  <a href="group__DRV__CRC__MODULE.html#ga6f0880155b752d7ecca5b70d8ef01481">More...</a><br /></td></tr>
<tr class="separator:ga6f0880155b752d7ecca5b70d8ef01481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ae14c7bf586f1da844ae3644ad88a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab7ae14c7bf586f1da844ae3644ad88a5">CRC_PATTERN_COUNT_MAX</a>&#160;&#160;&#160;(0x000FFFFFU)</td></tr>
<tr class="memdesc:gab7ae14c7bf586f1da844ae3644ad88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro defines maximum value of CRC Pattern Count.  <a href="group__DRV__CRC__MODULE.html#gab7ae14c7bf586f1da844ae3644ad88a5">More...</a><br /></td></tr>
<tr class="separator:gab7ae14c7bf586f1da844ae3644ad88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c3ca92f87e43eac13ed8b1a4d047e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga55c3ca92f87e43eac13ed8b1a4d047e5">CRC_SECTOR_COUNT_MAX</a>&#160;&#160;&#160;(0x0000FFFFU)</td></tr>
<tr class="memdesc:ga55c3ca92f87e43eac13ed8b1a4d047e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro defines maximum value of CRC Sector Count.  <a href="group__DRV__CRC__MODULE.html#ga55c3ca92f87e43eac13ed8b1a4d047e5">More...</a><br /></td></tr>
<tr class="separator:ga55c3ca92f87e43eac13ed8b1a4d047e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf48a2ec41a1833daf437a5b5f418ce0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gabf48a2ec41a1833daf437a5b5f418ce0">CRC_BCTOPLD_MAX</a>&#160;&#160;&#160;(0x00FFFFFFU)</td></tr>
<tr class="memdesc:gabf48a2ec41a1833daf437a5b5f418ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro defines maximum value of CRC Block Complete Timeout Counter Preload.  <a href="group__DRV__CRC__MODULE.html#gabf48a2ec41a1833daf437a5b5f418ce0">More...</a><br /></td></tr>
<tr class="separator:gabf48a2ec41a1833daf437a5b5f418ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55e6a41e1f12e95078a3f5607efbb01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab55e6a41e1f12e95078a3f5607efbb01">CRC_WDTOPLD_MAX</a>&#160;&#160;&#160;(0x00FFFFFFU)</td></tr>
<tr class="memdesc:gab55e6a41e1f12e95078a3f5607efbb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro defines maximum value of CRC Watchdog Timeout Counter Preload.  <a href="group__DRV__CRC__MODULE.html#gab55e6a41e1f12e95078a3f5607efbb01">More...</a><br /></td></tr>
<tr class="separator:gab55e6a41e1f12e95078a3f5607efbb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9294997846b77e35c1b705b366b5f47c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga9294997846b77e35c1b705b366b5f47c">CRC_MAX_NUM_OF_CHANNELS</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="memdesc:ga9294997846b77e35c1b705b366b5f47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of channels supported in CRC.  <a href="group__DRV__CRC__MODULE.html#ga9294997846b77e35c1b705b366b5f47c">More...</a><br /></td></tr>
<tr class="separator:ga9294997846b77e35c1b705b366b5f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CRC Operation Mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb2a01012fa5157a62a00e94962a28fd1"></a><a class="anchor" id="crcOperationMode_t"></a></p>
</td></tr>
<tr class="memitem:ga5450d088cdc236ce3aea07bf37464502"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a></td></tr>
<tr class="memdesc:ga5450d088cdc236ce3aea07bf37464502"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode.  <a href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">More...</a><br /></td></tr>
<tr class="separator:ga5450d088cdc236ce3aea07bf37464502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4ebfa5613df736539e437ee6a3e4be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga6f4ebfa5613df736539e437ee6a3e4be">CRC_OPERATION_MODE_DATA</a>&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_DATA)</td></tr>
<tr class="separator:ga6f4ebfa5613df736539e437ee6a3e4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e286c4c4793e43acaf4982aa0d42dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab5e286c4c4793e43acaf4982aa0d42dd">CRC_OPERATION_MODE_AUTO</a>&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_AUTO)</td></tr>
<tr class="separator:gab5e286c4c4793e43acaf4982aa0d42dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0797abc78201d0116cdeb089c23e7c5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga0797abc78201d0116cdeb089c23e7c5f">CRC_OPERATION_MODE_SEMICPU</a>&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_SEMICPU)</td></tr>
<tr class="separator:ga0797abc78201d0116cdeb089c23e7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f6f4cf60d54b5e3d5c3ae1d156c645"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga92f6f4cf60d54b5e3d5c3ae1d156c645">CRC_OPERATION_MODE_FULLCPU</a>&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_FULLCPU)</td></tr>
<tr class="separator:ga92f6f4cf60d54b5e3d5c3ae1d156c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CRC channel</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf6f29114e1fee284f4fe3229285ed6f3"></a><a class="anchor" id="crcChannel_t"></a></p>
</td></tr>
<tr class="memitem:ga2a4441992bd1824965c309668ca0e4c4"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a></td></tr>
<tr class="memdesc:ga2a4441992bd1824965c309668ca0e4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC channel supported.  <a href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">More...</a><br /></td></tr>
<tr class="separator:ga2a4441992bd1824965c309668ca0e4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d17d733014859dfc19819634448819"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga57d17d733014859dfc19819634448819">CRC_CHANNEL_1</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="separator:ga57d17d733014859dfc19819634448819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada53a26b1800997b1753800d68bf161e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gada53a26b1800997b1753800d68bf161e">CRC_CHANNEL_2</a>&#160;&#160;&#160;(0x2U)</td></tr>
<tr class="separator:gada53a26b1800997b1753800d68bf161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf99faed433e1976bc5e7ad746c2ab26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gacf99faed433e1976bc5e7ad746c2ab26">CRC_CHANNEL_3</a>&#160;&#160;&#160;(0x3U)</td></tr>
<tr class="separator:gacf99faed433e1976bc5e7ad746c2ab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67803ecc33c7e440411cc02394329947"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga67803ecc33c7e440411cc02394329947">CRC_CHANNEL_4</a>&#160;&#160;&#160;(0x4U)</td></tr>
<tr class="separator:ga67803ecc33c7e440411cc02394329947"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CRC Interrupt Priority</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf1c286315e807301f081c0cde74d93e7"></a><a class="anchor" id="crcIntrPriority_t"></a></p>
<p>The offset for the highest pending priority interrupt. These interrupt offset returned in <a class="el" href="group__DRV__CRC__MODULE.html#ga6123f3d71a683cc23a18264376007e63" title="This API is used to get the pending interrupt with highest priority.">CRCGetHighestPriorityIntrStatus</a> function </p>
</td></tr>
<tr class="memitem:ga83b2e093a6aaef69c40bfe37eafb8d06"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga83b2e093a6aaef69c40bfe37eafb8d06">crcIntrPriority_t</a></td></tr>
<tr class="memdesc:ga83b2e093a6aaef69c40bfe37eafb8d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset for the highest pending priority interrupt. These interrupt offset returned in <a class="el" href="group__DRV__CRC__MODULE.html#ga6123f3d71a683cc23a18264376007e63" title="This API is used to get the pending interrupt with highest priority.">CRCGetHighestPriorityIntrStatus</a> function.  <a href="group__DRV__CRC__MODULE.html#ga83b2e093a6aaef69c40bfe37eafb8d06">More...</a><br /></td></tr>
<tr class="separator:ga83b2e093a6aaef69c40bfe37eafb8d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0bcff3b5fea0f76eaeea56f548fbacd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaf0bcff3b5fea0f76eaeea56f548fbacd">CRC_INTR_PRIORITY_CH1_FAIL</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="separator:gaf0bcff3b5fea0f76eaeea56f548fbacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2525692c90dcfea6a66881deb820aea4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga2525692c90dcfea6a66881deb820aea4">CRC_INTR_PRIORITY_CH2_FAIL</a>&#160;&#160;&#160;(0x2U)</td></tr>
<tr class="separator:ga2525692c90dcfea6a66881deb820aea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eacfea38950745e1522de23b1c92c64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga3eacfea38950745e1522de23b1c92c64">CRC_INTR_PRIORITY_CH3_FAIL</a>&#160;&#160;&#160;(0x3U)</td></tr>
<tr class="separator:ga3eacfea38950745e1522de23b1c92c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bf5e862f8bdf2d2e4e31987c4c178d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga33bf5e862f8bdf2d2e4e31987c4c178d">CRC_INTR_PRIORITY_CH4_FAIL</a>&#160;&#160;&#160;(0x4U)</td></tr>
<tr class="separator:ga33bf5e862f8bdf2d2e4e31987c4c178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a839205d2236bfa142c110ab9b5409"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab3a839205d2236bfa142c110ab9b5409">CRC_INTR_PRIORITY_CH1_COMPRESSION_DONE</a>&#160;&#160;&#160;(0x9U)</td></tr>
<tr class="separator:gab3a839205d2236bfa142c110ab9b5409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677df3a64eaf62d7c4040d1cf651e64f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga677df3a64eaf62d7c4040d1cf651e64f">CRC_INTR_PRIORITY_CH2_COMPRESSION_DONE</a>&#160;&#160;&#160;(0xaU)</td></tr>
<tr class="separator:ga677df3a64eaf62d7c4040d1cf651e64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14040dec5bb9b03014563ae3d6e4080a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga14040dec5bb9b03014563ae3d6e4080a">CRC_INTR_PRIORITY_CH3_COMPRESSION_DONE</a>&#160;&#160;&#160;(0xbU)</td></tr>
<tr class="separator:ga14040dec5bb9b03014563ae3d6e4080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562cea43e68304362372728dbe95620a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga562cea43e68304362372728dbe95620a">CRC_INTR_PRIORITY_CH4_COMPRESSION_DONE</a>&#160;&#160;&#160;(0xcU)</td></tr>
<tr class="separator:ga562cea43e68304362372728dbe95620a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3293b5a0b3d5146e0339ee9babfcf5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga0f3293b5a0b3d5146e0339ee9babfcf5">CRC_INTR_PRIORITY_CH1_OVERRUN</a>&#160;&#160;&#160;(0x11U)</td></tr>
<tr class="separator:ga0f3293b5a0b3d5146e0339ee9babfcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafffeda058e94610c4f886ad7cbfe0861"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gafffeda058e94610c4f886ad7cbfe0861">CRC_INTR_PRIORITY_CH2_OVERRUN</a>&#160;&#160;&#160;(0x12U)</td></tr>
<tr class="separator:gafffeda058e94610c4f886ad7cbfe0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16b749610362595fa8b963ca8b807cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gaa16b749610362595fa8b963ca8b807cc">CRC_INTR_PRIORITY_CH3_OVERRUN</a>&#160;&#160;&#160;(0x13U)</td></tr>
<tr class="separator:gaa16b749610362595fa8b963ca8b807cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafc87754fdea64530113311667631d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gacafc87754fdea64530113311667631d5">CRC_INTR_PRIORITY_CH4_OVERRUN</a>&#160;&#160;&#160;(0x14U)</td></tr>
<tr class="separator:gacafc87754fdea64530113311667631d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e09e25bbf4d40e32a998cfb4722bfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gac9e09e25bbf4d40e32a998cfb4722bfd">CRC_INTR_PRIORITY_CH1_UNDERRUN</a>&#160;&#160;&#160;(0x19U)</td></tr>
<tr class="separator:gac9e09e25bbf4d40e32a998cfb4722bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84fb4690f9a275e87000027b84c25c31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga84fb4690f9a275e87000027b84c25c31">CRC_INTR_PRIORITY_CH2_UNDERRUN</a>&#160;&#160;&#160;(0x1aU)</td></tr>
<tr class="separator:ga84fb4690f9a275e87000027b84c25c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5670f8c4a63d2ec6fe23f60735b703af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga5670f8c4a63d2ec6fe23f60735b703af">CRC_INTR_PRIORITY_CH3_UNDERRUN</a>&#160;&#160;&#160;(0x1bU)</td></tr>
<tr class="separator:ga5670f8c4a63d2ec6fe23f60735b703af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b62771edeb9db949205a53b411df4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab0b62771edeb9db949205a53b411df4b">CRC_INTR_PRIORITY_CH4_UNDERRUN</a>&#160;&#160;&#160;(0x1cU)</td></tr>
<tr class="separator:gab0b62771edeb9db949205a53b411df4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a57f7a4d78ac95d0e264b7481d00e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga97a57f7a4d78ac95d0e264b7481d00e0">CRC_INTR_PRIORITY_CH1_TIMEOUT</a>&#160;&#160;&#160;(0x21U)</td></tr>
<tr class="separator:ga97a57f7a4d78ac95d0e264b7481d00e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3896c33b797ebb126fcc5fb32537ab4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga3896c33b797ebb126fcc5fb32537ab4d">CRC_INTR_PRIORITY_CH2_TIMEOUT</a>&#160;&#160;&#160;(0x22U)</td></tr>
<tr class="separator:ga3896c33b797ebb126fcc5fb32537ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cfd57c7d710e3c99a757c35c4d4d670"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga8cfd57c7d710e3c99a757c35c4d4d670">CRC_INTR_PRIORITY_CH3_TIMEOUT</a>&#160;&#160;&#160;(0x23U)</td></tr>
<tr class="separator:ga8cfd57c7d710e3c99a757c35c4d4d670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc641c5c39d5208a42ac93fae9c5ce7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gafc641c5c39d5208a42ac93fae9c5ce7f">CRC_INTR_PRIORITY_CH4_TIMEOUT</a>&#160;&#160;&#160;(0x24U)</td></tr>
<tr class="separator:gafc641c5c39d5208a42ac93fae9c5ce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CRC data bus type mask</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf8c58f6eca4ebc7dac5dd944c8d8c4bc"></a><a class="anchor" id="crcDataBusMask_t"></a></p>
</td></tr>
<tr class="memitem:gab153b03e11b59b1219a3fb386950f956"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a></td></tr>
<tr class="memdesc:gab153b03e11b59b1219a3fb386950f956"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC data bus type mask selected for tracing control.  <a href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">More...</a><br /></td></tr>
<tr class="separator:gab153b03e11b59b1219a3fb386950f956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf3d171b97f5397cee67ce65f7d4d58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#gabaf3d171b97f5397cee67ce65f7d4d58">CRC_DATA_BUS_ITCM_MASK</a>&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_ITC_MEN_MASK)</td></tr>
<tr class="separator:gabaf3d171b97f5397cee67ce65f7d4d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f9cfb967ca6abb83ed0d198714f858d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga5f9cfb967ca6abb83ed0d198714f858d">CRC_DATA_BUS_DTCM_MASK</a>&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_DTC_MEN_MASK)</td></tr>
<tr class="separator:ga5f9cfb967ca6abb83ed0d198714f858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee7dc798976b6b7774a4cdadf754439"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga3ee7dc798976b6b7774a4cdadf754439">CRC_DATA_BUS_VBUSM_MASK</a>&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_MEN_MASK)</td></tr>
<tr class="separator:ga3ee7dc798976b6b7774a4cdadf754439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga784f7761d61e028a55685737e99ec095"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__CRC__MODULE.html#ga784f7761d61e028a55685737e99ec095">CRC_DATA_BUS_MASK_ALL</a></td></tr>
<tr class="separator:ga784f7761d61e028a55685737e99ec095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6f0880155b752d7ecca5b70d8ef01481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0880155b752d7ecca5b70d8ef01481">&#9670;&nbsp;</a></span>CRC_CHANNEL_IRQSTATUS_RAW_MAIN_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CHANNEL_IRQSTATUS_RAW_MAIN_ALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (uint32_t) ((uint32_t)CRC_INTS_CH1_CCITENS_MASK |  \</div>
<div class="line">                (uint32_t)CRC_INTR_CH1_FAILENR_MASK |  \</div>
<div class="line">                (uint32_t)CRC_INTR_CH1_OVERENR_MASK |  \</div>
<div class="line">                (uint32_t)CRC_INTR_CH1_UNDERENR_MASK | \</div>
<div class="line">                (uint32_t)CRC_INTR_CH1_TIME_OUT_ENR_MASK)</div>
</div><!-- fragment -->
<p>Macro defines mask for all the interrupts for a channel. </p>

</div>
</div>
<a id="gab7ae14c7bf586f1da844ae3644ad88a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ae14c7bf586f1da844ae3644ad88a5">&#9670;&nbsp;</a></span>CRC_PATTERN_COUNT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_PATTERN_COUNT_MAX&#160;&#160;&#160;(0x000FFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro defines maximum value of CRC Pattern Count. </p>

</div>
</div>
<a id="ga55c3ca92f87e43eac13ed8b1a4d047e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55c3ca92f87e43eac13ed8b1a4d047e5">&#9670;&nbsp;</a></span>CRC_SECTOR_COUNT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_SECTOR_COUNT_MAX&#160;&#160;&#160;(0x0000FFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro defines maximum value of CRC Sector Count. </p>

</div>
</div>
<a id="gabf48a2ec41a1833daf437a5b5f418ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf48a2ec41a1833daf437a5b5f418ce0">&#9670;&nbsp;</a></span>CRC_BCTOPLD_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_BCTOPLD_MAX&#160;&#160;&#160;(0x00FFFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro defines maximum value of CRC Block Complete Timeout Counter Preload. </p>

</div>
</div>
<a id="gab55e6a41e1f12e95078a3f5607efbb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab55e6a41e1f12e95078a3f5607efbb01">&#9670;&nbsp;</a></span>CRC_WDTOPLD_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_WDTOPLD_MAX&#160;&#160;&#160;(0x00FFFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro defines maximum value of CRC Watchdog Timeout Counter Preload. </p>

</div>
</div>
<a id="ga9294997846b77e35c1b705b366b5f47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9294997846b77e35c1b705b366b5f47c">&#9670;&nbsp;</a></span>CRC_MAX_NUM_OF_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_MAX_NUM_OF_CHANNELS&#160;&#160;&#160;(4U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max number of channels supported in CRC. </p>

</div>
</div>
<a id="ga6f4ebfa5613df736539e437ee6a3e4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f4ebfa5613df736539e437ee6a3e4be">&#9670;&nbsp;</a></span>CRC_OPERATION_MODE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_OPERATION_MODE_DATA&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_DATA)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CRC operation mode to Data Captures </p>

</div>
</div>
<a id="gab5e286c4c4793e43acaf4982aa0d42dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e286c4c4793e43acaf4982aa0d42dd">&#9670;&nbsp;</a></span>CRC_OPERATION_MODE_AUTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_OPERATION_MODE_AUTO&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_AUTO)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CRC operation mode to Auto </p>

</div>
</div>
<a id="ga0797abc78201d0116cdeb089c23e7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0797abc78201d0116cdeb089c23e7c5f">&#9670;&nbsp;</a></span>CRC_OPERATION_MODE_SEMICPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_OPERATION_MODE_SEMICPU&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_SEMICPU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CRC operation mode to Semi-CPU </p>

</div>
</div>
<a id="ga92f6f4cf60d54b5e3d5c3ae1d156c645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f6f4cf60d54b5e3d5c3ae1d156c645">&#9670;&nbsp;</a></span>CRC_OPERATION_MODE_FULLCPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_OPERATION_MODE_FULLCPU&#160;&#160;&#160;(CRC_CTRL2_CH1_MODE_FULLCPU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CRC operation mode to Full-CPU </p>

</div>
</div>
<a id="ga57d17d733014859dfc19819634448819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d17d733014859dfc19819634448819">&#9670;&nbsp;</a></span>CRC_CHANNEL_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CHANNEL_1&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select channel 1 for operation </p>

</div>
</div>
<a id="gada53a26b1800997b1753800d68bf161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada53a26b1800997b1753800d68bf161e">&#9670;&nbsp;</a></span>CRC_CHANNEL_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CHANNEL_2&#160;&#160;&#160;(0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select channel 2 for operation </p>

</div>
</div>
<a id="gacf99faed433e1976bc5e7ad746c2ab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf99faed433e1976bc5e7ad746c2ab26">&#9670;&nbsp;</a></span>CRC_CHANNEL_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CHANNEL_3&#160;&#160;&#160;(0x3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select channel 3 for operation </p>

</div>
</div>
<a id="ga67803ecc33c7e440411cc02394329947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67803ecc33c7e440411cc02394329947">&#9670;&nbsp;</a></span>CRC_CHANNEL_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CHANNEL_4&#160;&#160;&#160;(0x4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select channel 4 for operation </p>

</div>
</div>
<a id="gaf0bcff3b5fea0f76eaeea56f548fbacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0bcff3b5fea0f76eaeea56f548fbacd">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH1_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH1_FAIL&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 fail interrupt </p>

</div>
</div>
<a id="ga2525692c90dcfea6a66881deb820aea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2525692c90dcfea6a66881deb820aea4">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH2_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH2_FAIL&#160;&#160;&#160;(0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 fail interrupt </p>

</div>
</div>
<a id="ga3eacfea38950745e1522de23b1c92c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eacfea38950745e1522de23b1c92c64">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH3_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH3_FAIL&#160;&#160;&#160;(0x3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 fail interrupt </p>

</div>
</div>
<a id="ga33bf5e862f8bdf2d2e4e31987c4c178d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bf5e862f8bdf2d2e4e31987c4c178d">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH4_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH4_FAIL&#160;&#160;&#160;(0x4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 4 fail interrupt </p>

</div>
</div>
<a id="gab3a839205d2236bfa142c110ab9b5409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a839205d2236bfa142c110ab9b5409">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH1_COMPRESSION_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH1_COMPRESSION_DONE&#160;&#160;&#160;(0x9U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 compression done interrupt </p>

</div>
</div>
<a id="ga677df3a64eaf62d7c4040d1cf651e64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677df3a64eaf62d7c4040d1cf651e64f">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH2_COMPRESSION_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH2_COMPRESSION_DONE&#160;&#160;&#160;(0xaU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 2 compression done interrupt </p>

</div>
</div>
<a id="ga14040dec5bb9b03014563ae3d6e4080a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14040dec5bb9b03014563ae3d6e4080a">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH3_COMPRESSION_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH3_COMPRESSION_DONE&#160;&#160;&#160;(0xbU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 3 compression done interrupt </p>

</div>
</div>
<a id="ga562cea43e68304362372728dbe95620a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562cea43e68304362372728dbe95620a">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH4_COMPRESSION_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH4_COMPRESSION_DONE&#160;&#160;&#160;(0xcU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 4 compression done interrupt </p>

</div>
</div>
<a id="ga0f3293b5a0b3d5146e0339ee9babfcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3293b5a0b3d5146e0339ee9babfcf5">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH1_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH1_OVERRUN&#160;&#160;&#160;(0x11U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 overrun interrupt </p>

</div>
</div>
<a id="gafffeda058e94610c4f886ad7cbfe0861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafffeda058e94610c4f886ad7cbfe0861">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH2_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH2_OVERRUN&#160;&#160;&#160;(0x12U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 2 overrun interrupt </p>

</div>
</div>
<a id="gaa16b749610362595fa8b963ca8b807cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16b749610362595fa8b963ca8b807cc">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH3_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH3_OVERRUN&#160;&#160;&#160;(0x13U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 3 overrun interrupt </p>

</div>
</div>
<a id="gacafc87754fdea64530113311667631d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafc87754fdea64530113311667631d5">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH4_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH4_OVERRUN&#160;&#160;&#160;(0x14U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 4 overrun interrupt </p>

</div>
</div>
<a id="gac9e09e25bbf4d40e32a998cfb4722bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e09e25bbf4d40e32a998cfb4722bfd">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH1_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH1_UNDERRUN&#160;&#160;&#160;(0x19U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 underrun interrupt </p>

</div>
</div>
<a id="ga84fb4690f9a275e87000027b84c25c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84fb4690f9a275e87000027b84c25c31">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH2_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH2_UNDERRUN&#160;&#160;&#160;(0x1aU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 2 underrun interrupt </p>

</div>
</div>
<a id="ga5670f8c4a63d2ec6fe23f60735b703af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5670f8c4a63d2ec6fe23f60735b703af">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH3_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH3_UNDERRUN&#160;&#160;&#160;(0x1bU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 3 underrun interrupt </p>

</div>
</div>
<a id="gab0b62771edeb9db949205a53b411df4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b62771edeb9db949205a53b411df4b">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH4_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH4_UNDERRUN&#160;&#160;&#160;(0x1cU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 4 underrun interrupt </p>

</div>
</div>
<a id="ga97a57f7a4d78ac95d0e264b7481d00e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a57f7a4d78ac95d0e264b7481d00e0">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH1_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH1_TIMEOUT&#160;&#160;&#160;(0x21U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 1 timeout interrupt </p>

</div>
</div>
<a id="ga3896c33b797ebb126fcc5fb32537ab4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3896c33b797ebb126fcc5fb32537ab4d">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH2_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH2_TIMEOUT&#160;&#160;&#160;(0x22U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 2 timeout interrupt </p>

</div>
</div>
<a id="ga8cfd57c7d710e3c99a757c35c4d4d670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cfd57c7d710e3c99a757c35c4d4d670">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH3_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH3_TIMEOUT&#160;&#160;&#160;(0x23U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 3 timeout interrupt </p>

</div>
</div>
<a id="gafc641c5c39d5208a42ac93fae9c5ce7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc641c5c39d5208a42ac93fae9c5ce7f">&#9670;&nbsp;</a></span>CRC_INTR_PRIORITY_CH4_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_INTR_PRIORITY_CH4_TIMEOUT&#160;&#160;&#160;(0x24U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset return for channel 4 timeout interrupt </p>

</div>
</div>
<a id="gabaf3d171b97f5397cee67ce65f7d4d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf3d171b97f5397cee67ce65f7d4d58">&#9670;&nbsp;</a></span>CRC_DATA_BUS_ITCM_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_DATA_BUS_ITCM_MASK&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_ITC_MEN_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select tracing control of instruction TCM </p>

</div>
</div>
<a id="ga5f9cfb967ca6abb83ed0d198714f858d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f9cfb967ca6abb83ed0d198714f858d">&#9670;&nbsp;</a></span>CRC_DATA_BUS_DTCM_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_DATA_BUS_DTCM_MASK&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_DTC_MEN_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select tracing control of data TCM </p>

</div>
</div>
<a id="ga3ee7dc798976b6b7774a4cdadf754439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee7dc798976b6b7774a4cdadf754439">&#9670;&nbsp;</a></span>CRC_DATA_BUS_VBUSM_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_DATA_BUS_VBUSM_MASK&#160;&#160;&#160;(CRC_MCRC_BUS_SEL_MEN_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select tracing control of VBUSM </p>

</div>
</div>
<a id="ga784f7761d61e028a55685737e99ec095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga784f7761d61e028a55685737e99ec095">&#9670;&nbsp;</a></span>CRC_DATA_BUS_MASK_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_DATA_BUS_MASK_ALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                    (CRC_MCRC_BUS_SEL_ITC_MEN_MASK | \</div>
<div class="line">                                    CRC_MCRC_BUS_SEL_DTC_MEN_MASK | \</div>
<div class="line">                                    CRC_MCRC_BUS_SEL_MEN_MASK)</div>
</div><!-- fragment --><p>Select tracing control of all data buses </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5450d088cdc236ce3aea07bf37464502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5450d088cdc236ce3aea07bf37464502">&#9670;&nbsp;</a></span>crcOperationMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode. </p>

</div>
</div>
<a id="ga2a4441992bd1824965c309668ca0e4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a4441992bd1824965c309668ca0e4c4">&#9670;&nbsp;</a></span>crcChannel_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC channel supported. </p>

</div>
</div>
<a id="ga83b2e093a6aaef69c40bfe37eafb8d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b2e093a6aaef69c40bfe37eafb8d06">&#9670;&nbsp;</a></span>crcIntrPriority_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__CRC__MODULE.html#ga83b2e093a6aaef69c40bfe37eafb8d06">crcIntrPriority_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The offset for the highest pending priority interrupt. These interrupt offset returned in <a class="el" href="group__DRV__CRC__MODULE.html#ga6123f3d71a683cc23a18264376007e63" title="This API is used to get the pending interrupt with highest priority.">CRCGetHighestPriorityIntrStatus</a> function. </p>

</div>
</div>
<a id="gab153b03e11b59b1219a3fb386950f956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab153b03e11b59b1219a3fb386950f956">&#9670;&nbsp;</a></span>crcDataBusMask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC data bus type mask selected for tracing control. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf1d528be4ec219989ea1c82a2a53080f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d528be4ec219989ea1c82a2a53080f">&#9670;&nbsp;</a></span>CRCInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCInitialize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcWatchdogPreload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcBlockPreload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CRC channel and will configure watchdog and block preload value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be initializaed. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcWatchdogPreload</td><td>It is used to check if DMA does supply a block of data responding to a request in a given time frame. </td></tr>
    <tr><td class="paramname">crcBlockPreload</td><td>It is used to check if CRC for an entire block is completed in a given time frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel initialization status. CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gaf2883454c481524baf9ba8594a6d6d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2883454c481524baf9ba8594a6d6d57">&#9670;&nbsp;</a></span>CRCVerifyInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyInitialize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcWatchdogPreload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcBlockPreload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the CRC watchdog and block preload value initialized for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be verified initialization. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcWatchdogPreload</td><td>It is used to check if DMA does supply a block of data responding to a request in a given time frame. </td></tr>
    <tr><td class="paramname">crcBlockPreload</td><td>It is used to check if CRC for an entire block is completed in a given time frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel verfiy initialization status. CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify initialization failed </dd></dl>

</div>
</div>
<a id="gab100922d0ce9e269d1fb0ac524ec71cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab100922d0ce9e269d1fb0ac524ec71cb">&#9670;&nbsp;</a></span>CRCConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcPatternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcSectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a>&#160;</td>
          <td class="paramname"><em>crcMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will configure CRC mode, pattern and sector count for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be configured. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcPatternCount</td><td>Number of data patterns in one sector to be compressed. </td></tr>
    <tr><td class="paramname">crcSectorCount</td><td>Number of sectors in a block of memory. </td></tr>
    <tr><td class="paramname">crcMode</td><td>CRC operational mode. Refer <a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502" title="CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode.">crcOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel configuration status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga559bd16f4436d4bf626a479fa70f5540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559bd16f4436d4bf626a479fa70f5540">&#9670;&nbsp;</a></span>CRCVerifyConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcPatternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcSectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a>&#160;</td>
          <td class="paramname"><em>crcMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will verify the configure of CRC mode, pattern and sector count for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be verified configuration. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcPatternCount</td><td>Number of data patterns in one sector to be compressed. </td></tr>
    <tr><td class="paramname">crcSectorCount</td><td>Number of sectors in a block of memory. </td></tr>
    <tr><td class="paramname">crcMode</td><td>CRC operational mode. Refer <a class="el" href="group__DRV__CRC__MODULE.html#ga5450d088cdc236ce3aea07bf37464502" title="CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode.">crcOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel configuration status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify configure failed </dd></dl>

</div>
</div>
<a id="ga986eb01b813b10a74bc20ee60a748eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga986eb01b813b10a74bc20ee60a748eef">&#9670;&nbsp;</a></span>CRCChannelReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCChannelReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to reset the CRC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which reset is to be done. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel reset status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga308100fb0c56aabeeb2dcad350173233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga308100fb0c56aabeeb2dcad350173233">&#9670;&nbsp;</a></span>CRCGetPSASigRegAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASigRegAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrcSignatureRegAddr__t.html">crcSignatureRegAddr_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCRegAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the PSA register address for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA register address is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCRegAddr</td><td>Pointer to CRC PSA register address structure. Refer structure <a class="el" href="structcrcSignatureRegAddr__t.html" title="Structure for accessing CRC registers address which are 64 bit wide.">crcSignatureRegAddr_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA signature register address status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gae1ad20b7cb7075cad634a01e0f084dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ad20b7cb7075cad634a01e0f084dcb">&#9670;&nbsp;</a></span>CRCGetPSASig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCPSASign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the PSA register value for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA register data is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCPSASign</td><td>Pointer to CRC PSA signature values. Refer struct <a class="el" href="structcrcSignature__t.html" title="Structure for accessing CRC register data which are 64 bit wide.">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA signature register value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gad49330fea3c0ac807ae8e9e70f00a5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49330fea3c0ac807ae8e9e70f00a5e4">&#9670;&nbsp;</a></span>CRCSetPSASeedSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCSetPSASeedSig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCPSASeedSign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set the PSA seed value without compression for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA seed value to be set. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCPSASeedSign</td><td>Pointer to CRC PSA seed signature values. Refer struct <a class="el" href="structcrcSignature__t.html" title="Structure for accessing CRC register data which are 64 bit wide.">crcSignature_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel set PSA seed value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga1eab9ba6d3098f09fb5c23445005a54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eab9ba6d3098f09fb5c23445005a54b">&#9670;&nbsp;</a></span>CRCGetPSASectorSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASectorSig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCSectorSign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get sector signature Value/ CRC value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number which was configured for CRC calculation. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCSectorSign</td><td>Pointer to CRC PSA sector signature values Refer struct <a class="el" href="structcrcSignature__t.html" title="Structure for accessing CRC register data which are 64 bit wide.">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA sector signaure value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga6123f3d71a683cc23a18264376007e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6123f3d71a683cc23a18264376007e63">&#9670;&nbsp;</a></span>CRCGetHighestPriorityIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetHighestPriorityIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pIntVecAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the pending interrupt with highest priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">pIntVecAddr</td><td>Pointer to highest priority pending interrupt vector address defined in <a class="el" href="group__DRV__CRC__MODULE.html#ga83b2e093a6aaef69c40bfe37eafb8d06" title="The offset for the highest pending priority interrupt. These interrupt offset returned in CRCGetHighe...">crcIntrPriority_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC get interrupt vector address status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gaab02b753542d9f0ef26f9cca56e91ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab02b753542d9f0ef26f9cca56e91ecf">&#9670;&nbsp;</a></span>CRCGetIntrStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pIntrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the pending interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which pending interrupt is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>.</td></tr>
    <tr><td class="paramname">pIntrStatus</td><td>Pointer to pending interrupt status/occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC get pending interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga2403b0f0b751df526cd4898569bf436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2403b0f0b751df526cd4898569bf436d">&#9670;&nbsp;</a></span>CRCEnableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCEnableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to enable. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC enable interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga356d6deabd7fbe11005ad0e903975045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356d6deabd7fbe11005ad0e903975045">&#9670;&nbsp;</a></span>CRCDisableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCDisableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to disable interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to disable. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC disable interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gab71509ef795b47e2400a72c47109f9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71509ef795b47e2400a72c47109f9b6">&#9670;&nbsp;</a></span>CRCClearIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCClearIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to clear interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to clear. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to clear status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC clear interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga79190e984729641dd78a7f123a8628e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79190e984729641dd78a7f123a8628e1">&#9670;&nbsp;</a></span>CRCPowerDownCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCPowerDownCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control the power down of the CRC module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Pointer to power control flag. CSL_TRUE: power down the CRC. CSL_FALSE: power on the CRC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC power control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga155f2eb0b82fa4811ac4f625607db982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga155f2eb0b82fa4811ac4f625607db982">&#9670;&nbsp;</a></span>CRCIsBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCIsBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBusyFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to check if CRC is busy for given Channel. </p>
<pre class="fragment">  During Auto or Semi-CPU mode, the busy flag is set when the first data
  pattern of the block is compressed and remains set until the the last
  data pattern of the block is compressed. The flag is cleared when the
  last data pattern of the block is compressed.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which busy status is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>.</td></tr>
    <tr><td class="paramname">pBusyFlag</td><td>Pointer to busy flag. CSL_TRUE: CRC channel is busy. CSL_FALSE: CRC channel is free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel check busy status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gaf7bee1b027384ffecae6828a1b6512f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bee1b027384ffecae6828a1b6512f4">&#9670;&nbsp;</a></span>CRCGetCurSecNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetCurSecNum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pCurSecNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the current sector number of which the signature verification fails in AUTO mode for given channel. </p>
<p>When a sector fails, the erroneous sector number is logged and the CRC fail interrupt is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which the curent sector number is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCurSecNum</td><td>Pointer to current sector number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get current sector number status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga52320890e39ad27ff3ab9561402be321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52320890e39ad27ff3ab9561402be321">&#9670;&nbsp;</a></span>CRCGetCurPSASig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetCurPSASig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCurPSASig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get current known good signature value/ CRC value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which current CRC value is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCurPSASig</td><td>Pointer to current CRC PSA signature values Refer struct <a class="el" href="structcrcSignature__t.html" title="Structure for accessing CRC register data which are 64 bit wide.">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get current PSA signaure value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="ga56d1b2540776a00821c0bfce73234e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56d1b2540776a00821c0bfce73234e1f">&#9670;&nbsp;</a></span>CRCGetRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetRawData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrcSignature__t.html">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pRawData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the uncompressed raw data value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which raw data value is to get. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported.">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pRawData</td><td>Pointer to raw data value Refer struct <a class="el" href="structcrcSignature__t.html" title="Structure for accessing CRC register data which are 64 bit wide.">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get raw data value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gac3d5dc88321f5e5561aff2ddf7e7a047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d5dc88321f5e5561aff2ddf7e7a047">&#9670;&nbsp;</a></span>CRCDataBusTracingCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCDataBusTracingCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>dataBusMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>busEnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control the CRC data bus tracing. </p>
<pre class="fragment">  Data tracing is only available on channel 1, when it is enabled, the
  operation mode is automatically reset to data capture mode on channel 1
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Data bus tracing control flag. CSL_TRUE: enable data tracing. CSL_FALSE: disable data tracing. </td></tr>
    <tr><td class="paramname">dataBusMask</td><td>Data bus mask bits for which what data buses are to be selected. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control.">crcDataBusMask_t</a>. </td></tr>
    <tr><td class="paramname">busEnableMask</td><td>Data bus enable mask bits for which what data buses are to be enabled or disabled. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control.">crcDataBusMask_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC data bus tracing control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a id="gab5967fdbd2766ecca927d8fccbb51b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5967fdbd2766ecca927d8fccbb51b01">&#9670;&nbsp;</a></span>CRCVerifyBusTracingCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyBusTracingCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>dataBusMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>busEnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to verify the control the CRC data bus tracing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Data bus tracing control flag. CSL_TRUE: enable data tracing. CSL_FALSE: disable data tracing. </td></tr>
    <tr><td class="paramname">dataBusMask</td><td>Data bus mask bits for which what data buses are to be selected. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control.">crcDataBusMask_t</a>. </td></tr>
    <tr><td class="paramname">busEnableMask</td><td>Data bus enable mask bits for which what data buses are to be enabled or disabled. Values given by <a class="el" href="group__DRV__CRC__MODULE.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control.">crcDataBusMask_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC verify data bus tracing control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify failed </dd></dl>

</div>
</div>
<a id="gafd1c4a11fa93f281a505a527601d8e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd1c4a11fa93f281a505a527601d8e2d">&#9670;&nbsp;</a></span>CRCReadStaticRegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCrc__StaticRegs.html">Crc_StaticRegs</a> *&#160;</td>
          <td class="paramname"><em>pStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read static registers of CRC module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CRC Registers.</td></tr>
    <tr><td class="paramname">pStaticRegs</td><td>pointer to static registers to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success CSL_EBADARGS - API fails due to bad input arguments </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
