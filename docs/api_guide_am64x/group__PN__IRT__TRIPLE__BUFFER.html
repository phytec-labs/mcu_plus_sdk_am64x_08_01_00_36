<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Triple buffer management APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__PN__IRT__TRIPLE__BUFFER.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Triple buffer management APIs<div class="ingroups"><a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html">APIs for Profinet Device FWHAL</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf6211b517bbfc9c142d974c3d3b1387e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaf6211b517bbfc9c142d974c3d3b1387e">PN_getPpmBuff</a> (<a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *pkt)</td></tr>
<tr class="memdesc:gaf6211b517bbfc9c142d974c3d3b1387e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to buffer indicated by NEXT <br  />
This will be the next available free buffer(in the triple buffer scheme). Stack can now fill this buffer and once done call <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">PN_relPpmBuff</a> to indicate the PRU on new data.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#gaf6211b517bbfc9c142d974c3d3b1387e">More...</a><br /></td></tr>
<tr class="separator:gaf6211b517bbfc9c142d974c3d3b1387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a606160332ad907c3d4d75fe234d9c"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">PN_relPpmBuff</a> (<a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a> pnHandle, <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *pkt)</td></tr>
<tr class="memdesc:ga87a606160332ad907c3d4d75fe234d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap NEXT with LAST and return new NEXT address <br  />
.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">More...</a><br /></td></tr>
<tr class="separator:ga87a606160332ad907c3d4d75fe234d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa037338a3b8ea628bebe61ed4db30c8b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaa037338a3b8ea628bebe61ed4db30c8b">PN_checkLastPPM</a> (<a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a> pnHandle, <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *pkt)</td></tr>
<tr class="memdesc:gaa037338a3b8ea628bebe61ed4db30c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update proc pointer in paket object and udpate descriptor if there is a new last buffer.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#gaa037338a3b8ea628bebe61ed4db30c8b">More...</a><br /></td></tr>
<tr class="separator:gaa037338a3b8ea628bebe61ed4db30c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd72037e79577f87ea28e058faebebc5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gacd72037e79577f87ea28e058faebebc5">PN_nextCpmRdy</a> (<a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a> pnHandle, <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *pkt)</td></tr>
<tr class="memdesc:gacd72037e79577f87ea28e058faebebc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap CPM NEXT with LAST and set validLast flag.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#gacd72037e79577f87ea28e058faebebc5">More...</a><br /></td></tr>
<tr class="separator:gacd72037e79577f87ea28e058faebebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7c48193cc9e2e72d208925fe3d7589"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga0f7c48193cc9e2e72d208925fe3d7589">PN_getLastCpm</a> (<a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a> pnHandle, <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *pkt)</td></tr>
<tr class="memdesc:ga0f7c48193cc9e2e72d208925fe3d7589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap CPM LAST with PROC if validLast is true, clear validLast flag.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#ga0f7c48193cc9e2e72d208925fe3d7589">More...</a><br /></td></tr>
<tr class="separator:ga0f7c48193cc9e2e72d208925fe3d7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34c216e6c3035a97527a599503715a4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gab34c216e6c3035a97527a599503715a4">PN_cpmBuffLock</a> (<a class="el" href="structPRUICSS__HwAttrs.html">PRUICSS_HwAttrs</a> const *pruicssHwAttrs, uint8_t pos, <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga674ae1fd341bc2690b5e0b813457f7ac">buffLocks</a> buff)</td></tr>
<tr class="memdesc:gab34c216e6c3035a97527a599503715a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks CPM Buffer indicating that ARM is consuming the particular buffer. PRU cannot write to this buffer.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#gab34c216e6c3035a97527a599503715a4">More...</a><br /></td></tr>
<tr class="separator:gab34c216e6c3035a97527a599503715a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga674ae1fd341bc2690b5e0b813457f7ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga674ae1fd341bc2690b5e0b813457f7ac">buffLocks</a> { <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acaf29ce29ccd064efe3c826ded29bebc7b">BUFF1</a> = 0, 
<a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acaaf257919b23e80c035de0152de01a3c9">BUFF2</a>, 
<a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7aca3978fb2f26d16db0f42cb858e25b8edd">BUFF3</a>, 
<a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acab07e48fbdc37e45b52c39e388bfd0673">NOBUFF</a>
 }</td></tr>
<tr class="memdesc:ga674ae1fd341bc2690b5e0b813457f7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the Buffer indexes of Triple buffers. Buffer lock needs to be aligned with firmware.  <a href="group__PN__IRT__TRIPLE__BUFFER.html#ga674ae1fd341bc2690b5e0b813457f7ac">More...</a><br /></td></tr>
<tr class="separator:ga674ae1fd341bc2690b5e0b813457f7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga674ae1fd341bc2690b5e0b813457f7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674ae1fd341bc2690b5e0b813457f7ac">&#9670;&nbsp;</a></span>buffLocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga674ae1fd341bc2690b5e0b813457f7ac">buffLocks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the Buffer indexes of Triple buffers. Buffer lock needs to be aligned with firmware. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga674ae1fd341bc2690b5e0b813457f7acaf29ce29ccd064efe3c826ded29bebc7b"></a>BUFF1&#160;</td><td class="fielddoc"><p>Buffer Index 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga674ae1fd341bc2690b5e0b813457f7acaaf257919b23e80c035de0152de01a3c9"></a>BUFF2&#160;</td><td class="fielddoc"><p>Buffer Index 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga674ae1fd341bc2690b5e0b813457f7aca3978fb2f26d16db0f42cb858e25b8edd"></a>BUFF3&#160;</td><td class="fielddoc"><p>Buffer Index 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga674ae1fd341bc2690b5e0b813457f7acab07e48fbdc37e45b52c39e388bfd0673"></a>NOBUFF&#160;</td><td class="fielddoc"><p>No Buffer <br  />
 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf6211b517bbfc9c142d974c3d3b1387e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6211b517bbfc9c142d974c3d3b1387e">&#9670;&nbsp;</a></span>PN_getPpmBuff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* PN_getPpmBuff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to buffer indicated by NEXT <br  />
This will be the next available free buffer(in the triple buffer scheme). Stack can now fill this buffer and once done call <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga87a606160332ad907c3d4d75fe234d9c">PN_relPpmBuff</a> to indicate the PRU on new data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>pointer to packet object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to NEXT packet buffer address </dd></dl>

</div>
</div>
<a id="ga87a606160332ad907c3d4d75fe234d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a606160332ad907c3d4d75fe234d9c">&#9670;&nbsp;</a></span>PN_relPpmBuff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* PN_relPpmBuff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>&#160;</td>
          <td class="paramname"><em>pnHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap NEXT with LAST and return new NEXT address <br  />
. </p>
<p>This API is called when stack has completed updating data to the buffer received from <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gaf6211b517bbfc9c142d974c3d3b1387e">PN_getPpmBuff</a>. This indicates the PRU about data update and updates the <a class="el" href="group__INDUSTRIAL__COMMS__PROFINET__DEVICE__FWHAL__MODULE.html#ga180104733d54734641dc00b6bdd160c8">ACTIVE_LIST</a> directly. Stack can now start filling data in the NEXT buffer returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnHandle</td><td>Profinet Handle </td></tr>
    <tr><td class="paramname">pkt</td><td>pointer to packet object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to NEXT packet buffer address </dd></dl>

</div>
</div>
<a id="gaa037338a3b8ea628bebe61ed4db30c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa037338a3b8ea628bebe61ed4db30c8b">&#9670;&nbsp;</a></span>PN_checkLastPPM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PN_checkLastPPM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>&#160;</td>
          <td class="paramname"><em>pnHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update proc pointer in paket object and udpate descriptor if there is a new last buffer. </p>
<p>Called from the <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gab293eff8169194e785fd0cb225e9353a">PN_ppmIsrHandler</a>. The PRU firmware checks if there is a new buffer available to send by checking the validLast flag in <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> . If available swaps the proc buffer(which is currently being send by the PRU), with the last buffer(the buffer which holds the latest data produced by the stack). This ensures that the PRU sends out latest available valid data at any point of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnHandle</td><td>Profinet Handle </td></tr>
    <tr><td class="paramname">pkt</td><td>pointer to packet object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1: new buffer activated <br  />
 0: no buffer update &lt;0: Not a PPM packet </dd></dl>

</div>
</div>
<a id="gacd72037e79577f87ea28e058faebebc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd72037e79577f87ea28e058faebebc5">&#9670;&nbsp;</a></span>PN_nextCpmRdy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PN_nextCpmRdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>&#160;</td>
          <td class="paramname"><em>pnHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap CPM NEXT with LAST and set validLast flag. </p>
<p>Called from <a class="el" href="group__PN__CPM__PPM__MANAGEMENT.html#gac201da1f145f5f79ac6cd3791ec3dfff">PN_cpmIsrHandler</a> , when a new CPM frame has arrived and sets the validLast flag in <a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> . When the stack is ready to receive an updated CPM packet, it calls <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga0f7c48193cc9e2e72d208925fe3d7589">PN_getLastCpm</a> and this LAST packet is consumed by the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnHandle</td><td>Profinet Handle </td></tr>
    <tr><td class="paramname">pkt</td><td>pointer to packet object </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>buffers swapped <br  />
</td></tr>
    <tr><td class="paramname">1</td><td>buffers swapped and overrun detected<br  />
This indicates the validLast flag was already set, and the stack has missed to consume a CPM packet </td></tr>
    <tr><td class="paramname">-1</td><td>error - wrong packet type<br  />
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f7c48193cc9e2e72d208925fe3d7589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7c48193cc9e2e72d208925fe3d7589">&#9670;&nbsp;</a></span>PN_getLastCpm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* PN_getLastCpm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PN__Handle_8h.html#ada5f9f33afc81eb9c9cd231fc4945a0c">PN_Handle</a>&#160;</td>
          <td class="paramname"><em>pnHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__rtcPacket.html">t_rtcPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap CPM LAST with PROC if validLast is true, clear validLast flag. </p>
<p>When the stack is ready to consume a new CPM packet, this API is called. This swaps the LAST buffer(which has the latest updated/consumed data by the PRU firmware) and the PROC buffer(which is being currently consumed by the stack). This also locks the new PROC buffer indicating that the Stack is consuming this buffer(PRU won't write to this buffer)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pnHandle</td><td>Profinet Handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pkt</td><td>pointer to packet object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer PROC buffer address </dd></dl>

</div>
</div>
<a id="gab34c216e6c3035a97527a599503715a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab34c216e6c3035a97527a599503715a4">&#9670;&nbsp;</a></span>PN_cpmBuffLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PN_cpmBuffLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPRUICSS__HwAttrs.html">PRUICSS_HwAttrs</a> const *&#160;</td>
          <td class="paramname"><em>pruicssHwAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#ga674ae1fd341bc2690b5e0b813457f7ac">buffLocks</a>&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks CPM Buffer indicating that ARM is consuming the particular buffer. PRU cannot write to this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pruicssHwAttrs</td><td>PRUICSS HW Attributes for base addresses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>CPM descriptor position Valid Range 0-7 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Indicates the index of Buffer Valid values for "buff" are <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acaf29ce29ccd064efe3c826ded29bebc7b">BUFF1</a> - Indicating the first buffer <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acaaf257919b23e80c035de0152de01a3c9">BUFF2</a> - Indicating the second buffer <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7aca3978fb2f26d16db0f42cb858e25b8edd">BUFF3</a> - Indicating the third buffer <a class="el" href="group__PN__IRT__TRIPLE__BUFFER.html#gga674ae1fd341bc2690b5e0b813457f7acab07e48fbdc37e45b52c39e388bfd0673">NOBUFF</a> - Indicates No buffer selected</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
