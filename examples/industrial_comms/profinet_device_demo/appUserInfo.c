/*!
 *  \example appUserInfo.c
 *
 *  \brief
 *  Callback functions to provide necessary information for the stack
 *
 *  \author
 *  KUNBUS GmbH
 *
 *  \date
 *  2020-06-19
 *
 *  \copyright 
 *  Copyright (c) 2021, KUNBUS GmbH<br /><br />
 *  All rights reserved.<br />
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:<br />
 *  <ol>
 *  <li>Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.</li>
 *  <li>Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.</li>
 *  <li>Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.</li>
 *  </ol>
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <osal.h>

#include "PN_API_IM.h"
#include "PN_API_SNMP.h"

#include "appUserInfo.h"
#include "appPermanentData.h"
#include "appHwBoardInfo.h"

uint32_t APP_UI_globalError_g = 0;

uint8_t aCycDataInput_g[CYC_DATA_INPUT_LEN];
uint8_t aCycDataOutput_g[CYC_DATA_OUTPUT_LEN];

static void APP_UI_applyPermanentEthData(void);
static void APP_UI_applyPermanentSnmpData(void);

uint8_t macAddr[APP_HW_BOARD_INFO_MAC_ADDR_LEN_TOTAL]; //True

/*!
*  <!-- Description: -->
* \brief
* Get first interface MAC address.
*
* \details
* Get first interface MAC address.
* A 2-port PROFINET device uses three MAC addresses: for the physical interface and one for each port.
* User must specify the MAC address of the physical interface and pass it to the stack.
* Stack will generate MAC addresses for the ports by adding 1 and 2 to the interface address respectively.
* Important: Therefore for a PROFINET device three consecutive MAC addresses must be reserved.
* Example:
* Interface MAC - {0xc8, 0x3e, 0xa7, 0x00, 0x00, 0x1b} -> specified by the user.
* Port 1    MAC - {0xc8, 0x3e, 0xa7, 0x00, 0x00, 0x1c} -> generated by the stack.
* Port 2    MAC - {0xc8, 0x3e, 0xa7, 0x00, 0x00, 0x1d} -> generated by the stack.
* 
* <!-- Parameters and return values: -->
*
*  \return Pointer to the first byte of the interface MAC address.
*
*/
uint8_t *APP_UI_getMacAddr (
    void)
{
    //return &APP_HW_BOARD_INFO_getMacInfo().macAddr[0]; // True commented
    macAddr[0] = 0xc1b; // True
    macAddr[1] = 0xc00; // True
    macAddr[2] = 0x00; // True
    macAddr[3] = 0xa7; // True
    macAddr[4] = 0x3e; // True
    macAddr[5] = 0xc9; // True
    return &macAddr[0]; // True
}

/*!
*  <!-- Description: -->
* \brief
* Example of the error handling callback function.
*
* \details
* This callback function can be registered as error handler for stack internal errors.
* Currently, it can be registered to process:
* - OSAL errors;
* - PROFINET stack errors;
*
* \remarks
* OSAL error codes are defined in osal_error.h
* PROFINET error code are defined internally and are not visible for the user.
*
* <!-- Parameters and return values: -->
*
* \param[in]  errorCode_p       Error code.
* \param[in]  fatal_p           Indication, if the error is fatal.
* \param[in]  paraCnt_p         Number of variadic arguments.
* \param[in]  argptr_p          Pointer to the variadic argument list.
*/
void APP_UI_cbErrorHandler (
    uint32_t errorCode_p,
    bool fatal_p,
    uint8_t paraCnt_p,
    va_list argptr_p)
{
    int32_t indexArg;
    uint32_t arg;

    APP_UI_globalError_g = errorCode_p;

    OSAL_printf ("\r\nError: 0x%8.8x, Fatal: %s", errorCode_p, fatal_p ? "yes" : "no");
    for (indexArg = 0; indexArg < paraCnt_p; indexArg++)
    {   // assume all Parameters are 32bit unsigned integer
        arg = va_arg (argptr_p, uint32_t);
        OSAL_printf (", P%d: 0x%8.8x", indexArg, arg);
    }

    if (fatal_p == true)
    {
        /* It could be possible to introduce a while loop here, f */
        exit (1);
    }
}

/*!
*  <!-- Description: -->
* \brief
* Example of the callback function for conveying local time to the stack.
*
* \details
* This function, if registered, will be called by stack in case it needs to know current time. E.g. for log entries.
* TBD
*
*
* <!-- Parameters and return values: -->
*
*/
void APP_UI_cbGetLocalTime (
    uint32_t *pTimeHigh_p,
    uint32_t *pTimeLow_p)
{
    /*Here the time value should be assigned.*/
}

/*!
*  <!-- Description: -->
* \brief
* Example of the callback function for conveying server boot time to the stack.
*
* \details
* This function, if registered, will be called by stack in case it needs to know server boot time.
* E.g. for the RPC protocol.
* According to DCE 1.1:Remote Procedure Call specification:
*
* The server boot time is a 32-bit non-negative integer that indicates the time at which the current
* instantiation of a server was booted; that is, the time at which the process in which the server is
* running was created, not the time at which the server host was booted. Server boot time is
* represented as time in seconds since 1 January 1970 and must increase with each boot of the
* server.
*
* <!-- Parameters and return values: -->
*
* \param[out]  pTime_p       Pointer to write server boot time value to.
*
*/
void APP_UI_cbGetServerBootTime (
    uint32_t *pTime_p)
{
    /*Here assign the time value.*/
    static uint32_t time = 0;

    *pTime_p = time;
}

/*!
*  <!-- Description: -->
* \brief
* Example of the callback function for initiating a signalization.
*
* \details
* After receiving the FLASH_ONCE command from DCP protocol, PROFINET device must initiate flashing of an LED
* (e.g. the Ethernet LINK LED) or an alternative signalization with a duration of 3 s.
* If registered, stack will call this function with a duration of 3s and 2Hz frequency (500 ms on, 500 ms off).
* The state parameter indicates, if application shall currently switch on or switch off its signalization means.
*
* <!-- Parameters and return values: -->
*
* \param[out]  state_p       On true - signalization ON, on false - signalization OFF.
*/
void APP_UI_cbSignalLinkLed (
    bool state_p)
{
    /* Here signalization means shall be introduced. */
}

/*!
*  <!-- Description: -->
* \brief
* Example of the callback function for indication of station name modification.
*
* \details
* This function will be called by stack in case of station name of the PROFINET device has been changed.
* In this example new station name will be stored only to the working copy of the permanent data.
* Permanent storage to OSPI flash shall be done separately, if desired.
*
* <!-- Parameters and return values: -->
*
* \param[in]  pName_p       Pointer to the name string.
* \param[in]  length_p      Name length.
*/
void APP_UI_cbSetStationName (
    const uint8_t *pName_p,
    uint16_t length_p)

{

    APP_SPermanentData_t *pPermanentData = APP_getPermStorage ();

    pPermanentData->stationNameLength = length_p;
    memset (pPermanentData->aStationName, 0, sizeof (pPermanentData->aStationName));
    memcpy (pPermanentData->aStationName, pName_p, length_p);
}

/*!
*  <!-- Description: -->
* \brief
* Example of the callback function for indication of the IP address modification.
*
* \details
* This function will be called by stack in case of the IP address of the PROFINET device has been changed.
* In this example new IP address will be stored only to the working copy of the permanent data.
* Permanent storage to OSPI flash shall be done separately, if desired.
*
* <!-- Parameters and return values: -->
*
* \param[in]  ipAddress_p       IP address.
* \param[in]  subNetMask_p      Subnet mask.
* \param[in]  gateWayAddress_p  Gateway Address.
*/
void APP_UI_cbSetIpAddress (
    uint32_t ipAddress_p,
    uint32_t subNetMask_p,
    uint32_t gateWayAddress_p)

{
    APP_SPermanentData_t *pPermanentData = APP_getPermStorage ();

    pPermanentData->ipAddress = ipAddress_p;
    pPermanentData->subNetMask = subNetMask_p;
    pPermanentData->gateWayAddress = gateWayAddress_p;
}

/*!
*  <!-- Description: -->
* \brief
* Factory Reset callback.
*
* \details
* Example of a callback function, that must be registered to PROFINET stack for indication of the "FactoryReset" command.
*
* After receiving the "FactoryReset" command, the working copy of all relevant data for the specified mode will be set to default factory value.
* This data must be stored permanently as well. Nevertheless permanent storage must not be done in this callback.
* After coming back from this function, stack will subsequently invoke another callback for save permanent storage indication. See APP_UI_cbSavePermanentData
*
* \remarks
* FactoryReset / ResetToFactory behavior of I&M data is specified. Refer to IEC CD 61158-6-10 IEC:2021 : 5.2.7.2 Reset behavior.
* Therefore it can be done completely by stack. PN_API_IM_resetToFactory API function shall be used for this.
* The only exception is I&M4 data. Here application must specify explicitly, if I&M 4 data shall be set factory setting.
* 
* <!-- Parameters and return values: -->
*
*
*/
void APP_UI_cbFactoryReset (
    void)

{
    bool resetIm4 = true;

    //Overwrite the working copy of concerned data with default factory values.
    APP_factoryResetPermStorage();

    //Apply modified data to concerned run-time objects.
    APP_UI_applyPermanentEthData();
    APP_UI_applyPermanentSnmpData();

    //Set I&M data to factory settings.
    PN_API_IM_resetToFactory(resetIm4);
}

/*!
*  <!-- Description: -->
* \brief
* Reset to Factory callback.
*
* \details
* Example of a callback function, that must be registered to PROFINET stack for indication of the "ResetToFactory" command.
* Stack will pass a block qualifier, to specify the "Reset to Factory" mode.
*
* Current example implements only "Reset Communication Parameters" mode, which is mandatory for every PROFINET device.
* For information about the modes refer to IEC CD 61158-5-10 IEC 2021: 6.3.11.4.2 Set / Block Qualifier.
*
* After receiving the "ResetToFactory" command, the working copy of all relevant data for the specified mode will be set to default factory value.
* This data must be stored permanently as well. Nevertheless permanent storage must not be done in this callback.
* After coming back from this function, stack will subsequently invoke another callback for save permanent storage indication. See APP_UI_cbSavePermanentData
* 
* <!-- Parameters and return values: -->
*
* \param[in]  qualifier_p       Reset to Factory mode.
*
*/
bool APP_UI_cbResetToFactory (
    PN_API_ETH_EDcpResetToFactoryQualifier_t qualifier_p)
{
    bool result = false;

    switch (qualifier_p)
    {
        case PN_API_ETH_eDCP_RESET_TO_FACTORY_COMMUNICATION_PARAMETER:
        {
            //Overwrite the working copy of concerned data with default factory values.
            APP_resetCommParamPermStorage();
            
            //Apply modified data to concerned run-time objects.
            APP_UI_applyPermanentEthData();
            APP_UI_applyPermanentSnmpData();

            result = true;
        }   break;
        default:
        {
        }   break;
    }

    return result;
}

/*!
*  <!-- Description: -->
* \brief
* Write Port Data Check callback.
*
* \details
* Example of a callback function for indication the Write PD Port Data Check command.
* In this example application stores port check data to permanent data.
* 
* <!-- Parameters and return values: -->
*
* \param[in]  port_p    - Indication of the port (Port 1 / Port 2)
* \param[in]  pData_p   - Pointer to received port check data.
*
*/
void APP_UI_cbWritePortDataCheck (
    PN_API_ETH_EPort_t port_p,
    const PN_API_ETH_SPortDataCheck_t *pData_p)

{
    APP_SPermanentData_t *pPermanentData = NULL;
    pPermanentData = APP_getPermStorage();

    switch (port_p)
    {
        case PN_API_ETH_ePORT_1:
        {
            memcpy (&pPermanentData->permanentPortData.portDataCheckPort1, pData_p, sizeof (PN_API_ETH_SPortDataCheck_t));
        }   break;
        case PN_API_ETH_ePORT_2:
        {
            memcpy (&pPermanentData->permanentPortData.portDataCheckPort2, pData_p, sizeof (PN_API_ETH_SPortDataCheck_t));
        }   break;
        default:
        {
        }   break;
    }
}

/*!
*  <!-- Description: -->
* \brief
* Write Port Data Adjust callback.
*
* \details
* Example of a callback function for indication the Write PD Port Data Adjust command.
* In this example application stores port adjust data to permanent data.
*
* <!-- Parameters and return values: -->
*
* \param[in]  port_p    - Indication of the port (Port 1 / Port 2)
* \param[in]  pData_p   - Pointer to received port adjust data.
*
*/
void APP_UI_cbWritePortDataAdjust (
    PN_API_ETH_EPort_t port_p,
    const PN_API_ETH_SPortDataAdjust_t *pData_p)
{
    APP_SPermanentData_t *pPermanentData = NULL;
    
    pPermanentData = APP_getPermStorage();

    switch (port_p)
    {
        case PN_API_ETH_ePORT_1:
        {
            memcpy (&pPermanentData->permanentPortData.portDataAdjustPort1, pData_p, sizeof (PN_API_ETH_SPortDataAdjust_t));
        }   break;
        case PN_API_ETH_ePORT_2:
        {
            memcpy (&pPermanentData->permanentPortData.portDataAdjustPort2, pData_p, sizeof (PN_API_ETH_SPortDataAdjust_t));
        }   break;
        default:
        {
        }   break;
    }
}

/*!
*  <!-- Description: -->
* \brief
* Set permanent SNMP data callback.
*
* \details
* Callback function to store SNMP to permanent data.
*
* <!-- Parameters and return values: -->
*
* \param[in]  pData_p   - Pointer to SNMP data.
*
*/
void APP_UI_cbSetPermanentSnmpData (
    const PN_API_SNMP_SPermanentData_t *pData_p)

{
    APP_SPermanentData_t *pPermanentData = NULL;
    
    pPermanentData = APP_getPermStorage();

    memcpy (&pPermanentData->permanentSnmpData, pData_p, sizeof (PN_API_SNMP_SPermanentData_t));
}

/*!
*  <!-- Description: -->
* \brief
* Save permanent data callback.
*
* \details
* Callback for storing working copy of permanent data to the permanent storage.
*
* <!-- Parameters and return values: -->
*
*/
void APP_UI_cbSavePermanentData (
    void)

{
    APP_SPermanentData_t *pPermanentData = NULL;
    
    pPermanentData = APP_getPermStorage();

    APP_savePermStorage (pPermanentData);
}

/*!
*  <!-- Description: -->
* \brief
* Recover permanent data for Ethernet interface
*
* \details
* This helper function recovers data, relevant for Ethernet interface. 
* Is being used e.g. after factory reset.
* 
* <!-- Parameters and return values: -->
*
*/
static void APP_UI_applyPermanentEthData (
    void)

{
    uint32_t result                         = PN_API_ETH_eOK;
    PN_API_ETH_SPermanentDcpData_t dcpData  = {0};
    APP_SPermanentData_t *pPermanentData    = NULL; 
    
    pPermanentData = APP_getPermStorage();

    dcpData.ipAddress = pPermanentData->ipAddress;
    dcpData.subnetMask = pPermanentData->subNetMask;
    dcpData.gateway = pPermanentData->gateWayAddress;

    dcpData.stationNameLength = pPermanentData->stationNameLength;
    memcpy (dcpData.aStationName, pPermanentData->aStationName, pPermanentData->stationNameLength);

    result = PN_API_ETH_applyPermanentDcpData (&dcpData);
    if (result != PN_API_ETH_eOK)
    {
        goto laError;
    }

    result = PN_API_ETH_applyPermanentPortData (&pPermanentData->permanentPortData);
    if (result != PN_API_ETH_eOK)
    {
        goto laError;
    }

    return;

laError:
    OSAL_printf("\r[APP] ERROR: Error while recovering data for Ethernet interface. Error code:  0x%8.8x\n", result);
    return;
}

/*!
*  <!-- Description: -->
* \brief
* Recover permanent data for SNMP interface
*
* \details
* This helper function recovers data, relevant for SNMP interface.
* Is being used e.g. after factory reset.
*
* <!-- Parameters and return values: -->
*
*/
void APP_UI_applyPermanentSnmpData(
    void)
{
    uint32_t result                         = PN_API_SNMP_eOK;
    APP_SPermanentData_t *pPermanentData    = NULL;
    
    pPermanentData = APP_getPermStorage();

    result = PN_API_SNMP_applyPermanentData(&pPermanentData->permanentSnmpData);

    if (result != PN_API_SNMP_eOK)
    {
        goto laError;
    }

    return;

laError:
    OSAL_printf("\r[APP] ERROR: Error while recovering data for SNMP interface. Error code:  0x%8.8x\n", result);
    return;
}

/*!
*  <!-- Description: -->
* \brief
* Get serial number.
*
* \details
* Returns the serial number of the PROFINET device as an integer value.
*
* <!-- Parameters and return values: -->
*
* \return   Serial number of the PROFINET device as uint32_t.
*/
uint32_t APP_UI_getSerialNumber (
    void)

{
    return PNC_DEVICE_SERIAL_NUMBER;
}

/*!
*  <!-- Description: -->
* \brief
* Returns the serial number of the PROFINET device as a visible string.
*
* \details
* Function converts the serial number of the PROFINET device from integer to an array of visible characters (string).
* That means, that all unused characters will be set to blank (0x20) to fill the whole length of the string.
* The length of the string is specified by the caller.
*
* <!-- Parameters and return values: -->
*
* \param[out]  pBuffer_p         Pointer to the buffer to write to.
* \param[int]  length_p          Buffer length.
*/
void APP_UI_getSerialNumberString (
    uint8_t *pBuffer_p,                   //!< [out] Buffer for serial num string
    uint16_t length_p)                    //!< [in] Length of buffer

{
    uint16_t indexBegin;
    uint16_t indexEnd;
    uint32_t serialNumber;
    uint16_t length;
    uint32_t reminder;
    uint8_t tmp;

    if (length_p < 1)
    {
        OSAL_printf ("\r\nInvalid serial number string buffer.");
        return;
    }

    memset (pBuffer_p, ' ', length_p);

    serialNumber = APP_UI_getSerialNumber ();
    length = 0;

    if (serialNumber == 0)
    {
        pBuffer_p[length++] = '0';
    }
    else
    {
        while (serialNumber != 0)
        {
            if (length >= length_p)
            {   // use buffer as long as it is
                break;
            }
            reminder = serialNumber % 10;
            pBuffer_p[length++] = reminder + '0';
            serialNumber /= 10;
        }
        // reverse String
        indexBegin = 0;
        indexEnd = length - 1;
        while (indexEnd > indexBegin)
        {
            tmp = pBuffer_p[indexBegin];
            pBuffer_p[indexBegin] = pBuffer_p[indexEnd];
            pBuffer_p[indexEnd] = tmp;

            indexBegin++;
            indexEnd--;
        }
    }
}

/*!
*  <!-- Description: -->
* \brief
* Get hardware revision.
*
* \details
* Returns the hardware revision of the PROFINET device as an integer value.
* 
* <!-- Parameters and return values: -->
*
* \return   Hardware revision of the PROFINET device as uint16_t.
*/
uint16_t APP_UI_getHardwareRevision (
    void)

{
    return PNC_DEVICE_HARDWARE_REVISION;
}


/*!
*  <!-- Description: -->
* \brief
* Returns the hardware revision of the PROFINET device as a visible string.
*
* \details
* Function converts the hardware revision of the PROFINET device  from integer to an array of visible characters (string).
* That means, that all unused characters will be set to blank (0x20) to fill the whole length of the string.
* The length of the string is specified by the caller.
*
* \remarks
*
* \warning
*
* <!-- Parameters and return values: -->
*
* \param[out]  pBuffer_p         Pointer to the buffer to write to.
* \param[int]  length_p          Buffer length.
*/
void APP_UI_getHardwareRevisionString(
    uint8_t *pBuffer_p,                   //!< [out] Buffer for serial num string
    uint16_t length_p)                    //!< [in] Length of buffer

{
    uint16_t indexBegin;
    uint16_t indexEnd;
    uint16_t hwRevision;
    uint16_t length;
    uint32_t reminder;
    uint8_t tmp;

    if (length_p < 1)
    {
        OSAL_printf ("\r\nInvalid hardware revision number string buffer.");
        return;
    }

    memset (pBuffer_p, ' ', length_p);

    hwRevision = APP_UI_getHardwareRevision ();
    length = 0;

    if (hwRevision == 0)
    {
        pBuffer_p[length++] = '0';
    }
    else
    {
        while (hwRevision != 0)
        {
            if (length >= length_p)
            {   // use buffer as long as it is
                break;
            }
            reminder = hwRevision % 10;
            pBuffer_p[length++] = reminder + '0';
            hwRevision /= 10;
        }
        // reverse String
        indexBegin = 0;
        indexEnd = length - 1;
        while (indexEnd > indexBegin)
        {
            tmp = pBuffer_p[indexBegin];
            pBuffer_p[indexBegin] = pBuffer_p[indexEnd];
            pBuffer_p[indexEnd] = tmp;

            indexBegin++;
            indexEnd--;
        }
    }
}

/*!
*  <!-- Description: -->
* \brief
* Get software functional enhancement.
*
* \details
* Returns the software functional enhancement attribute of the PROFINET device as an integer value.
*
* <!-- Parameters and return values: -->
*
* \return   Software functional enhancement of the PROFINET device as uint8_t.
*/
uint8_t APP_UI_getSwRevFuncEnhancement (
    void)

{
    return PNC_DEVICE_SW_REV_FUNC_ENHANCEMENT;
}

/*!
*  <!-- Description: -->
* \brief
* Returns the software functional enhancement attribute of the PROFINET device as a visible string.
*
* \details
*
* Function converts the software functional enhancement attribute of the PROFINET device from integer to an array of
* visible characters (string).
* That means, that all unused characters will be set to blank (0x20) to fill the whole length of the string.
* The length of the string is specified by the caller.
*
* <!-- Parameters and return values: -->
*
* \param[out]  pBuffer_p         Pointer to the buffer to write to.
* \param[int]  length_p          Buffer length.
*/
void APP_UI_getSwRevFuncEnhancementString(
    uint8_t *pBuffer_p,                   //!< [out] Buffer for serial num string
    uint16_t length_p)                    //!< [in] Length of buffer

{
    uint16_t indexBegin;
    uint16_t indexEnd;
    uint8_t funcEnhancement;
    uint16_t length;
    uint32_t reminder;
    uint8_t tmp;

    if (length_p < 1)
    {
        OSAL_printf ("\r\nInvalid functional enhancement number string buffer");
        return;
    }

    memset (pBuffer_p, ' ', length_p);

    funcEnhancement = APP_UI_getSwRevFuncEnhancement ();
    length = 0;

    if (funcEnhancement == 0)
    {
        pBuffer_p[length++] = '0';
    }
    else
    {
        while (funcEnhancement != 0)
        {
            if (length >= length_p)
            {   // use buffer as long as it is
                break;
            }
            reminder = funcEnhancement % 10;
            pBuffer_p[length++] = reminder + '0';
            funcEnhancement /= 10;
        }
        // reverse String
        indexBegin = 0;
        indexEnd = length - 1;
        while (indexEnd > indexBegin)
        {
            tmp = pBuffer_p[indexBegin];
            pBuffer_p[indexBegin] = pBuffer_p[indexEnd];
            pBuffer_p[indexEnd] = tmp;

            indexBegin++;
            indexEnd--;
        }
    }
}

/*!
*  <!-- Description: -->
* \brief
* Get software bug fix.
*
* \details
* Returns the software bug fix attribute of the PROFINET device as an integer value.
* 
* <!-- Parameters and return values: -->
*
* \return   Software bug fix attribute of the PROFINET device as uint8_t.
*/
uint8_t APP_UI_getSwRevBugFix (
    void)

{
    return PNC_DEVICE_SW_REV_BUG_FIX;
}


/*!
*  <!-- Description: -->
* \brief
* Returns the software bug fix attribute of the PROFINET device as a visible string.
*
* \details
* Function converts software bug fix attribute of the PROFINET device from integer to an array of visible characters (string).
* That means, that all unused characters will be set to blank (0x20) to fill the whole length of the string.
* The length of the string is specified by the caller.
*
* <!-- Parameters and return values: -->
*
* \param[out]  pBuffer_p         Pointer to the buffer to write to.
* \param[int]  length_p          Buffer length.
*/
void APP_UI_getSwRevBugFixString(
    uint8_t *pBuffer_p,                   //!< [out] Buffer for serial num string
    uint16_t length_p)                    //!< [in] Length of buffer

{
    uint16_t indexBegin;
    uint16_t indexEnd;
    uint8_t bugFix;
    uint16_t length;
    uint32_t reminder;
    uint8_t tmp;

    if (length_p < 1)
    {
        OSAL_printf ("\r\nInvalid bug fix number string buffer");
        return;
    }

    memset (pBuffer_p, ' ', length_p);

    bugFix = APP_UI_getSwRevBugFix ();
    length = 0;

    if (bugFix == 0)
    {
        pBuffer_p[length++] = '0';
    }
    else
    {
        while (bugFix != 0)
        {
            if (length >= length_p)
            {   // use buffer as long as it is
                break;
            }
            reminder = bugFix % 10;
            pBuffer_p[length++] = reminder + '0';
            bugFix /= 10;
        }
        // reverse String
        indexBegin = 0;
        indexEnd = length - 1;
        while (indexEnd > indexBegin)
        {
            tmp = pBuffer_p[indexBegin];
            pBuffer_p[indexBegin] = pBuffer_p[indexEnd];
            pBuffer_p[indexEnd] = tmp;

            indexBegin++;
            indexEnd--;
        }
    }
}

/*!
*  <!-- Description: -->
* \brief
* Get software internal change.
*
* \details
* Returns the software internal change attribute of the PROFINET device as an integer value.
*
* <!-- Parameters and return values: -->
*
* \return   Software internal change attribute of the PROFINET device as uint8_t.
*/
uint8_t APP_UI_getSwRevInternalChange (
    void)

{
    return PNC_DEVICE_SW_REV_INTERNAL_CHANGE;
}

/*!
*  <!-- Description: -->
* \brief
* Returns the software internal change attribute of the PROFINET device as a visible string.
*
* \details
* Function converts the software internal change attribute of the PROFINET device from integer
* to an array of visible characters (string).
* That means, that all unused characters will be set to blank (0x20) to fill the whole length of the string.
* The length of the string is specified by the caller.
*
* <!-- Parameters and return values: -->
*
* \param[out]  pBuffer_p         Pointer to the buffer to write to.
* \param[int]  length_p          Buffer length.
*
*/
void APP_UI_getSwRevInternalChangeString(
    uint8_t *pBuffer_p,                   //!< [out] Buffer for serial num string
    uint16_t length_p)                    //!< [in] Length of buffer

{
    uint16_t indexBegin;
    uint16_t indexEnd;
    uint8_t change;
    uint16_t length;
    uint32_t reminder;
    uint8_t tmp;

    if (length_p < 1)
    {
        OSAL_printf ("\r\nInvalid bug fix number string buffer");
        return;
    }

    memset (pBuffer_p, ' ', length_p);

    change = APP_UI_getSwRevInternalChange ();

    length = 0;
    if (change == 0)
    {
        pBuffer_p[length++] = '0';
    }
    else
    {
        while (change != 0)
        {
            if (length >= length_p)
            {   // use buffer as long as it is
                break;
            }
            reminder = change % 10;
            pBuffer_p[length++] = reminder + '0';
            change /= 10;
        }
        // reverse String
        indexBegin = 0;
        indexEnd = length - 1;
        while (indexEnd > indexBegin)
        {
            tmp = pBuffer_p[indexBegin];
            pBuffer_p[indexBegin] = pBuffer_p[indexEnd];
            pBuffer_p[indexEnd] = tmp;

            indexBegin++;
            indexEnd--;
        }
    }
}

/*!
*  <!-- Description: -->
* \brief
* Get revision counter.
*
* \details
* Returns the revision counter attribute of the PROFINET device as an integer value.
*
* <!-- Parameters and return values: -->
*
* \return   Revision counter attribute of the PROFINET device as uint16_t.
*/
uint16_t APP_UI_getDeviceRevCounter (
        void)
{
    return PNC_REVISION_COUNTER;
}
